<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stryker-mutator.io/blog</id>
    <title>Stryker Mutator Blog</title>
    <updated>2021-06-16T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stryker-mutator.io/blog"/>
    <subtitle>Stryker Mutator Blog</subtitle>
    <icon>https://stryker-mutator.io/images/stryker.svg</icon>
    <entry>
        <title type="html"><![CDATA[Stryker4s: from 40 minutes to 40 seconds]]></title>
        <id>stryker4s-40-minutes-to-40-seconds</id>
        <link href="https://stryker-mutator.io/blog/stryker4s-40-minutes-to-40-seconds"/>
        <updated>2021-06-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Stryker4s is your friendly mutation testing framework for Scala. Compared to earlier versions, Stryker4s 0.12 achieves a 60x speed increase in some scenarios ü§Ø. Are you curious to know how? Keep on reading.]]></summary>
        <content type="html"><![CDATA[<p>Stryker4s is your friendly mutation testing framework for Scala. Compared to earlier versions, Stryker4s <code>0.12</code> achieves a 60x speed increase in some scenarios ü§Ø. Are you curious to know how? Keep on reading.</p><p>If you&#x27;re new to mutation testing, it&#x27;s a way to measure your tests&#x27; effectiveness. A mutation testing framework will make small changes, called <em>mutants</em>, one by one in your source code. Then it will run your tests to see if one of them fails. If so, you just &quot;killed&quot; that mutant; if not, it &quot;survived&quot;. If too many mutants survive, you probably want to improve your tests. The mutation testing report will give you insides into the test cases you may have missed. If this all sounds complicated, please take a look at the recent talk <a href="https://www.youtube.com/watch?v=Vq9eqZzblfg">&quot;Who is testing your tests?&quot;</a> from <em>Scala Love in the City</em> or check out the rest of the <a href="/">website</a>.</p><p>In this blog we&#x27;ll talk about the performance improvements made in the last couple Stryker4s versions and dive into how they are made possible.</p><h2>üìÉ In short</h2><p>Imagine you&#x27;re on your way to a sunny holiday destination. You&#x27;ve checked in your luggage, gone through customs, and boarded the plane. Then, the plane moves forward a couple of meters, and you&#x27;re thrown out and sent back to customs before going through the whole thing again. It&#x27;ll take years before you get to sip on your umbrella cocktail üçπ! This is exactly how Stryker4s has been running your code‚Ä¶ until now.</p><p>A lot has changed in recent versions of Stryker4s. Stryker4s now runs your tests in an entirely different way, bringing big performance improvements. As an example, running Stryker4s on the Stryker4s codebase used to take about 40 minutes on <code>0.9.1</code>. On<code>0.12.1</code>, this has been reduced to a fast 40 seconds. A short list of some new features:</p><ul><li>‚ú® New testrunner boasting improved performance</li><li>üîÄ Concurrency to improve speed by using all available cores</li><li>üïµÔ∏è‚Äç‚ôÄÔ∏è Coverage analysis to skip mutants without coverage</li><li>‚è±Ô∏è Timeout detection in tests</li><li>üëΩ New mutator: regular expressions. Thanks to <a href="https://github.com/stryker-mutator/weapon-regex/">Weapon regeX</a>!</li></ul><p>In the rest of this blog post, we&#x27;ll do a deep-dive into the increased performance. Let&#x27;s start by taking a look at the older version of Stryker4s.</p><h2>üê¢ The old</h2><p>In the older sbt plugin, there was a lot of overhead in running your tests. As a quick reminder, Stryker4s uses <a href="https://stryker-mutator.io/blog/mutation-switching/">mutation switching</a>, so it only has to compile your code once, instead of for each mutant. After mutating your source code, Stryker4s would essentially just call <code>sbt test</code> with the mutated code for every mutant. This means sbt would:</p><ol><li>Look for code changes (which there never are).</li><li>Make sure all compiled code is up-to-date (which it always is).</li><li>Start a new Java process with your class files, dependencies, and a small sbt entry point library.</li><li>Run your tests and report the results back to the main sbt process.</li><li>Repeat for the next mutant.</li></ol><div _key="sbt-old" chart="
sequenceDiagram
  participant Stryker4s
  participant sbt
  participant sbt test process
  Stryker4s-&gt;&gt;sbt: Compile mutated code
  loop For each mutant
    Stryker4s-&gt;&gt;sbt: executeTests
    sbt-&gt;&gt;sbt: Check for changes?
    sbt-&gt;&gt;+sbt test process: Start new process and run tests
    sbt test process-&gt;&gt;-sbt: Report test results
    sbt-&gt;&gt;Stryker4s: Tests successful Y/N
  end
"></div><p>Doing those checks and starting a new process makes a lot of sense for a development workflow, but not for mutation testing. This implementation of the test runner hasn&#x27;t changed much in the two years that the plugin has existed. Time for some improvements!</p><h2>üêá The new</h2><p>It&#x27;s clear the process can be optimized. Once Stryker4s is set up and all mutations have been compiled, the only thing we really want to do is run some tests and get a result. Sbt doesn&#x27;t give plugins full control over the entire test process, but it does have all the information about <em>what</em> your project looks like. This is something we can work with!</p><h3>üèóÔ∏è Meet: build info</h3><p>The first thing Stryker4s needs to do is figure out what tests our project contains. One of the great things about sbt is its standardization and extensibility as a build tool. Because sbt knows exactly what your project looks like, plugins can retrieve all this information. To find out what tests you have, Stryker4s uses three pieces of information from sbt:</p><ol><li><code>fullClasspath</code> location of all dependency JARs (including test-dependencies) and <code>.class</code> files of your compiled code.</li><li><code>loadedTestFrameworks</code> the configured test framework. Sbt detects a couple of frameworks by default, but if you use MUnit you might remember having to add <code>testFrameworks += new TestFramework(&quot;munit.Framework&quot;)</code> to your build.sbt before MUnit can run.</li><li><code>testGrouping</code> contains every test suite sbt discovers in your project.</li></ol><p>You can try running these yourself in a sbt console to see how Stryker4s looks at your project:</p><pre><code>sbt:stryker4s-core&gt; show fullClasspath
[info] * Attributed(~/stryker4s/core/target/jvm-2.13/classes)
[info] * Attributed(~/.cache/coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-
library/2.13.4/scala-library-2.13.4.jar)
[info] * Attributed(~/.cache/coursier/v1/https/repo1.maven.org/maven2/com/github/pathikrit/
better-files_2.13/3.9.1/better-files_2.13-3.9.1.jar)
...
sbt:stryker4s-core&gt; show loadedTestFrameworks
[info] Map(TestFramework(org.scalatest.tools.Framework, org.scalatest.tools.ScalaTestFramework) -&gt; org
.scalatest.tools.Framework@2b9d52d5)
...
sbt:stryker4s-core&gt; show testGrouping
[info] * (&lt;default&gt;,Vector(Test stryker4s.config.TestFilterTest : subclass(false, org.scalatest.Suite)
, Test stryker4s.extension.FileExtensionsTest : subclass(false, org.scalatest.Suite), Test stryker4s.m
utants.MutatorTest : subclass(false, org.scalatest.Suite), Test stryker4s.mutants.AddAllMutationsTest
: subclass(false, org.scalatest.Suite), ...
</code></pre><p>We now know what tests are in your project. Let&#x27;s have a look at running those tests:</p><h3>üß™ Meet: test interfaces</h3><p>This is something our friends in the NodeJS world are (rightfully) a little <a href="https://stryker-mutator.io/docs/stryker-js/plugins#test-runners">jealous of</a> üòè. When you call <code>sbt test</code>, sbt will look for any registered test frameworks that implement the <a href="https://github.com/sbt/test-interface">test-interface</a> (from <code>loadedTestFrameworks</code>). This is a small collection of interfaces that let a test framework tell sbt how to run tests in that framework. Because all test frameworks in sbt implement this interface, we have a single programmatic way to call any test framework. It doesn&#x27;t matter if you&#x27;re using ScalaTest, MUnit, Weaver-test or anything else. Using a bit of reflection, we can create an instance of the test framework runner and run tests:</p><pre><code class="language-scala">val framework = classLoader.loadClass(testFrameworkClass).getConstructor().newInstance().asInstanceOf[Framework]
val runner = framework.runner(args, remoteArgs, classLoader)

val testTasks: Array[Task] = runner.tasks(testGrouping.taskDefs)

testTasks.foreach(testTask =&gt; {
  testTask.execute()
})
</code></pre><p>Stryker4s can then use this to activate a mutant and instantly run the tests without any overhead from sbt.</p><h3>üîÄ Meet: concurrency</h3><p>Stryker4s activates and runs each mutant one by one in isolation. This is to make sure one mutant won&#x27;t have an impact on the result of another. This is done by creating a separate process for it. However, there&#x27;s no rule that says we can&#x27;t start multiple Java processes at the same time and run those in parallel.</p><p>With multiple separate worker-processes, each worker has its own separate memory, threads, and active mutant. This way, if one mutant results in an <code>OutOfMemoryError</code> it won&#x27;t impact the others. In long-lived processes like mutation testing, the performance increases of parallelism far outweigh the overhead of starting and managing multiple workers.</p><h3>üß∞ Putting it all together</h3><p>Stryker4s can start a new process with all the information collected above. Because Stryker4s now fully controls how it runs your tests, it can eliminate any overhead of starting new processes or looking for source code changes. It looks a little something like this:</p><ol><li>Start new worker processes in parallel with the full test classpath and send them all the needed test setup.</li><li>Create a new instance of the test framework in the created process.</li><li>For each mutant, programmatically run the tests on the worker process.</li></ol><div _key="sbt-new" chart="
sequenceDiagram
  participant Stryker4s
  participant sbt
  participant testrunner worker
  Stryker4s-&gt;&gt;+sbt: compile
  sbt--&gt;&gt;-Stryker4s: .class files
  Stryker4s-&gt;&gt;+sbt: retrieve info
  sbt--&gt;&gt;-Stryker4s: project info
  Stryker4s-&gt;&gt;+testrunner worker: start &lt;n&gt; new workers
  loop For each mutant
    Stryker4s-&gt;&gt;testrunner worker: run tests
    testrunner worker--&gt;&gt;Stryker4s: report test result
  end
  Stryker4s-&gt;&gt;testrunner worker: close test worker
  testrunner worker--&gt;&gt;-Stryker4s: 
"></div><p>As you can see, there&#x27;s not much overhead left in running your tests. The limiting factor is now how fast your tests are! When running Stryker4s on itself, this method improves performance 60x: from 40 minutes to 40 seconds.</p><h2>üîÆ What&#x27;s next?</h2><p>In this post, we&#x27;ve shown you how Stryker4s uses sbt&#x27;s test information to reduce overhead and provide massive performance increases. We&#x27;re very excited for you to try out the increased performance! If you have any feedback or questions, find us on <a href="https://github.com/stryker-mutator/stryker4s">GitHub</a> or <a href="https://join.slack.com/t/stryker-mutator/shared_invite/enQtOTUyMTYyNTg1NDQ0LTU4ODNmZDlmN2I3MmEyMTVhYjZlYmJkOThlNTY3NTM1M2QxYmM5YTM3ODQxYmJjY2YyYzllM2RkMmM1NjNjZjM">Slack</a>.</p><p>Next, we want to also bring these performance improvements to the Maven plugin, add per-test coverage support, improve the HTML report to show your tests and perhaps even support some <a href="https://github.com/stryker-mutator/stryker4k">new languages</a>?</p>]]></content>
        <author>
            <name>Hugo van Rijswijk</name>
            <uri>https://github.com/hugo-vrijswijk</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Announcing StrykerJS 5.0 - Brave new Dimension]]></title>
        <id>announcing-stryker-js-5-brave-new-dimension.md</id>
        <link href="https://stryker-mutator.io/blog/announcing-stryker-js-5-brave-new-dimension.md"/>
        <updated>2021-05-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We're proud to announce the next major release of StrykerJS: 5.0. With a name change, a new dimension in your report, a new way to discover files, updated mutators, quality of life improvements, and minor bug fixes.]]></summary>
        <content type="html"><![CDATA[<p>We&#x27;re proud to announce the next major release of StrykerJS: 5.0. With a name change, a new dimension in your report, a new way to discover files, updated mutators, quality of life improvements, and minor bug fixes.</p><p>If you&#x27;re new to mutation testing, it&#x27;s a way to measure your tests&#x27; effectiveness. A mutation testing framework will make small changes, called <em>mutants</em>, one by one in your source code. Then it will run your tests to see if one of them fails. If so, you just &quot;killed&quot; that mutant; if not, it &quot;survived&quot;. If too many mutants survive, you probably want to improve your tests. The mutation testing report will give you insides into the test cases you may have missed. If this all sounds complicated, please take a look at <a href="https://stryker-mutator.io/example">our RoboBar ü§ñüç∑ example</a>.</p><p>If you&#x27;re new to StrykerJS, please follow our <a href="https://stryker-mutator.io/docs/stryker-js/getting-started/">Getting started guide</a>. Are you already using StrykerJS? Update to the latest version with your package manager of choice.</p><pre><code class="language-shell">npm install --save-dev @stryker-mutator/core@latest
# OR
yarn add --dev @stryker-mutator/core@latest
</code></pre><p>Don&#x27;t forget to do the same for any plugins you might be using. For example,</p><pre><code class="language-shell">npm install --save-dev @stryker-mutator/mocha-runner@latest
# OR
yarn add --dev @stryker-mutator/mocha-runner@latest
</code></pre><p>With that out of the way, let&#x27;s dive into the new stuff!</p><h2>üë™ Name change</h2><p>That&#x27;s right. We&#x27;ve rebranded &#x27;Stryker for JavaScript and friends&#x27; as simply <strong>StrykerJS</strong>. This change makes it easier to distinguish StrykerJS from other frameworks in the Stryker family (Stryker.NET and Stryker4s). It also allows for better use of Twitter real estate üòä.</p><p>Don&#x27;t worry; the names of the NPM packages haven&#x27;t changed. So it is purely a branding thing.</p><h2>‚ú® New dimension</h2><p>The mutation test report has always been the bread and butter of Stryker. Either in your browser or console, it is where you find out where the killed and survived mutants are. But the next question you might ask is: which tests were responsible? Stryker knows but wasn&#x27;t telling you. Until now!</p><p>Behold, the new dimension you&#x27;ll find in your reports‚Äîthe test view üß™.</p><p><img src="/images/blogs/test-view-html-1.png" alt="html test view"/>
<img src="/images/blogs/test-view-html-2.png" alt="html test view2"/></p><p>Or using the <code>clear-text</code> reporter:</p><p><img src="/images/blogs/test-view-console.png" alt="text test view"/></p><p>The test view tells you at a glance which tests are <em>killing</em> mutants, which are merely <em>covering</em> mutants (without killing) and which are <em>not covering</em> any mutants. Furthermore, you can determine which mutants were covered or killed by that particular test case. Finding out so much information about your tests has never been this easy!</p><p>A couple of caveats to point out:</p><ul><li>The <code>Covering</code> state will only be available when selecting the <a href="https://stryker-mutator.io/docs/stryker-js/configuration#coverageanalysis-string"><code>perTest</code> coverage analysis setting</a>.</li><li>StrykerJS always runs your tests with <code>bail</code> mode active (or <code>failFast</code> in jasmine), making your test runner stop after the first failing test. As a result, a mutant can only be killed by one test. If you have overlap in asserts across tests, other tests might be marked as &quot;Covering&quot;, while they would kill a mutant when run in isolation.</li><li>Some mutants are executed as soon as your file <em>is loaded</em> instead of during <em>test execution</em>. We call these mutants <em>static mutants</em>, and all your tests are executed as a result. For example:<pre><code class="language-diff">// hello.js
-export const hello =&#x27;üëã&#x27;
+export const hello = &#x27;&#x27;
</code></pre>A test that for <code>hello</code> might look like:<pre><code class="language-js">import { hello } from &#x27;./hello.js&#x27;;
describe(&#x27;hello&#x27;, () =&gt; {
  it(&#x27;should be a string&#x27;, () =&gt; expect(typeof hello).toBe(&#x27;string&#x27;));
});
</code></pre>As you can see, this is a relatively weak test that doesn&#x27;t kill this mutant. You might assume that this test covers the mutant, but upon further inspection, you&#x27;ll notice that <code>hello</code> is declared as soon as the file loads. There is no way for Stryker to know that this test is supposed to cover the mutant. As a result, the test is marked as &quot;Not Covering&quot;.</li><li>Currently, only the <code>@stryker-mutator/jest-runner</code> can group your tests in their original test files. Running with another test runner will result in your tests being displayed in a list instead.</li></ul><h2>ü§∑‚Äç‚ôÇÔ∏è Discovering files</h2><p>StrykerJS typically doesn&#x27;t mutate your files directly. Instead, it creates a copy inside a <em>sandbox</em> directory, usually located at <code>.stryker-tmp/sandbox-123456</code>. However, it won&#x27;t copy over all files there to save time. Stryker used to rely on git to decide which files to copy. Any <code>.gitignored</code> files would not be copied.</p><p>There were some issues with this approach. First of all, it required your project to be located in a git repository, and you needed to have git installed. And then, there are also examples of test suites that need some <code>.gitignore</code>d files to run, like <code>.env</code>.</p><p>To combat these issues, StrykerJS 5 will no longer use git for file discovery. Instead, it will include all files while ignoring some standard patterns, like &quot;node_modules&quot;. You can remove more files by specifying patterns in the new <a href="https://stryker-mutator.io/docs/stryker-js/configuration#ignorepatterns-string"><code>ignorePatterns</code></a> configuration option. For example:</p><pre><code class="language-json">{
  &quot;ignorePatterns&quot;: [&quot;bower_components&quot;]
}
</code></pre><p>StrykerJS also allows you to specify <code>files</code>, which does the opposite of <code>ignorePatterns</code>, namely, you select the files you need to run your tests. Painstakenly whitelisting each file is more time-consuming and prone to error; that&#x27;s why we&#x27;ve decided to <em>deprecate</em> <code>files</code> in favor of <code>ignorePatterns</code>.</p><p>Are you currently using <code>files</code>? You can probably remove <code>files</code>, and Stryker will still work. Or, if you still prefer the whitelisting method, you can achieve this like so:</p><pre><code class="language-json">{
  &quot;ignorePatterns&quot;: [&quot;**&quot;, &quot;!src/**/*.js&quot;]
}
</code></pre><p>See the <a href="https://github.com/stryker-mutator/stryker-js/pull/2848">original pull request</a> for more information.</p><h2>üëΩ Updated mutators</h2><p>We&#x27;ve decided to add a new variant to the <a href="https://stryker-mutator.io/docs/mutation-testing-elements/supported-mutators#logical-operator">logical operator mutator</a>. It now also mutates <em>the nullish coalescing operator</em> (<code>??</code>).</p><pre><code class="language-diff">-foo ?? bar
+foo &amp;&amp; bar
</code></pre><p>To kill this mutant, you will need to write a test for both branches of the operator. Like you already needed to do for the logical OR (<code>||</code>) and logical AND (<code>&amp;&amp;</code>) operators.</p><p>We&#x27;re also in the process of adding a new <a href="https://github.com/stryker-mutator/stryker-js/pull/2886">optional chaining mutator</a>, but that didn&#x27;t make it in time for this release.</p><p>A quick plug: as of version 4.4, StrykerJS will also mutate your <code>/regex/</code>s. For example:</p><pre><code class="language-diff">- /\d{4}\s?[a-Z]{2}/
+ /\d\s?[a-Z]{2}/
+ /\D{4}\s?[a-Z]{2}/
+ /\d{4}\S?[a-Z]{2}/
+ /\d{4}\s?[a-Z]/
+ /\d{4}\s?[^a-Z]{2}/
</code></pre><p>Thanks again to the students who created <a href="https://github.com/stryker-mutator/weapon-regex/">weapon-regex</a> to make this happen üéâ</p><h2>üïµÔ∏è‚Äç‚ôÇÔ∏è Default coverage analysis</h2><p>Coverage analysis is a feature that makes StrykerJS run faster because it will run fewer tests per mutant. In its strongest setting, <code>&quot;coverageAnalysis&quot;: &quot;perTest&quot;</code>, it will only run the exact tests that are covering a mutant. Whether or not you are able to use this feature depends on your test suite and test runner, see <a href="https://stryker-mutator.io/docs/stryker-js/configuration#coverageanalysis-string">coverage analysis in configuration</a> for more details.</p><p>Since v4.3, <code>@stryker-mutator/jest-runner</code> also supports this setting. Now that all officially supported test runners support coverage analysis, it was time to make <code>perTest</code> the default setting. So we did. You can still disable it with <code>&quot;coverageAnalysis&quot;: &quot;off&quot;</code></p><h2>üßπ Other changes</h2><p>We once again chose to improve the maintainability of the Stryker code base.</p><p><strong>Unified reporter api</strong></p><p>The Reporter plugin API has gotten an overhaul. It is now more in line with <a href="https://github.com/stryker-mutator/mutation-testing-elements/">mutation-testing-elements</a></p><p>See the <a href="https://github.com/stryker-mutator/stryker-js/pull/2798">original PR</a> for more information.</p><p><strong>Serialization</strong></p><p>Stryker uses worker processes to run tests and check mutants for type errors. These workers receive any options via a message. Stryker used the <a href="https://www.npmjs.com/package/surrial">surrial</a> package to serialize complex objects like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp</a>, functions, and even classes. This hidden feature was rarely used and not a good practice in hindsight. StrykerJS 5 replaces this with plain old <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse"><code>JSON.parse</code></a>. Don&#x27;t worry, you get a warning if you configure something that isn&#x27;t serializable.</p><p>See the <a href="https://github.com/stryker-mutator/stryker-js/pull/2877">original PR</a> for more information.</p><h2>üí• Breaking changes</h2><ul><li><p><strong>range:</strong> The <code>range</code> property is no longer present on a <code>mutant</code>. Note, this is a breaking change for plugin creators only.</p></li><li><p><strong>options:</strong> <code>&quot;perTest&quot;</code> is now the default value for &quot;coverageAnalysis&quot; when the configured test runner is not &quot;command&quot;. Explicitly set <code>&quot;coverageAnalysis&quot;: &quot;off&quot;</code> manually to opt-out of this behavior.</p></li><li><p><strong>node:</strong> Node 10 is no longer supported. Please use Node 12 or higher.</p></li><li><p><strong>serialize:</strong> Having a non-JSON-serializable value in your configuration won&#x27;t be sent to the child process anymore. If you really need them in your test runner configuration, you should isolate those values and put them in test runner-specific config files, loaded by the test runner plugin itself, for example, jest.config.js, karma.conf.js, webpack.config.js.</p></li><li><p><strong>ignore patterns:</strong> Stryker will no longer use a git command to determine which files belong to your project. Instead, it will rely on sane defaults. You can change this behavior by defining <a href="https://stryker-mutator.io/docs/stryker-js/configuration/#ignorepatterns-string"><code>ignorePatterns</code></a>.</p></li><li><p><strong>ignore patterns:</strong> The <code>files</code> configuration option is deprecated and will be removed in a future release. Please use <a href="https://stryker-mutator.io/docs/stryker-js/configuration/#ignorepatterns-string"><code>ignorePatterns</code></a> instead.</p><p>This:</p><pre><code class="language-json">{
  &quot;files&quot;: [&quot;foo.js&quot;]
}
</code></pre><p>Is equivalent to:</p><pre><code class="language-json">{
  &quot;ignorePatterns&quot;: [&quot;**&quot;, &quot;!foo.js&quot;]
}
</code></pre></li><li><p><strong>reporter api:</strong> Changes to <code>Reporter</code> and <code>TestRunner</code> plugin API of Stryker</p></li><li><p><strong>jest-runner:</strong> Support for project type <code>create-react-app-ts</code> is dropped from the jest-runner.</p></li></ul><h2>üéâ Thank you</h2><p>Thanks to everyone for your continued support! Have questions or issues? Don&#x27;t hesitate to contact us in <a href="https://join.slack.com/t/stryker-mutator/shared_invite/enQtOTUyMTYyNTg1NDQ0LTU4ODNmZDlmN2I3MmEyMTVhYjZlYmJkOThlNTY3NTM1M2QxYmM5YTM3ODQxYmJjY2YyYzllM2RkMmM1NjNjZjM">Slack</a>, on <a href="https://twitter.com/stryker_mutator/">Twitter</a> or open <a href="https://github.com/stryker-mutator/stryker-js/issues/new/choose">an issue</a>.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Announcing Stryker 4.0 - Mutation Switching]]></title>
        <id>announcing-stryker-4-mutation-switching</id>
        <link href="https://stryker-mutator.io/blog/announcing-stryker-4-mutation-switching"/>
        <updated>2020-10-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We're proud to announce the next major release of the Stryker mutation testing framework for JavaScript and friends: Stryker 4.0.]]></summary>
        <content type="html"><![CDATA[<p>We&#x27;re proud to announce the next major release of the Stryker mutation testing framework for JavaScript and friends: Stryker 4.0.</p><p>This release marks a fundamental shift in the way Stryker works internally. It now uses &quot;mutation switching&quot;, which improves performance and usability, similar to how Stryker.NET and Stryker4s already work. This change, unfortunately, couldn&#x27;t be done without breaking changes. See the breaking changes paragraph if you&#x27;re interested.</p><p><strong>üéß Listen to the <a target="_blank" rel="noopener noreferrer" href="https://thedeepdive.simplecast.com/episodes/mutation-testing-with-stryker">&quot;Mutation testing with Stryker&quot; podcast episode on InDepth.dev</a></strong></p><p>If you&#x27;re new to mutation testing, it&#x27;s a way to measure your tests&#x27; effectiveness. Please look at <a href="https://stryker-mutator.io/example">our RoboBar ü§ñüç∑ example</a> and see how even 100% code coverage doesn&#x27;t tell the whole story. Mutation testing is the only way to make sure you&#x27;re not missing any tests.</p><p><strong><em>Note: updated on 9 October 2020: add remark about TypeScript 3.7 requirement in <a href="#breaking-changes">Breaking changes</a>.</em></strong></p><h2>üöÄ Getting started</h2><p>If you&#x27;re new to Stryker, please follow the <a href="/stryker/quickstart">quickstart guide</a>.</p><p>If you&#x27;re already using Stryker, you can install this latest version with your package manager of choice.</p><pre><code class="language-shell">npm install --save-dev @stryker-mutator/core
</code></pre><p>Don&#x27;t forget to do the same for your Stryker plugins. Please note that the following plugins have been removed and are no longer needed:</p><ul><li><del>@stryker-mutator/typescript</del></li><li><del>@stryker-mutator/jasmine-framework</del></li><li><del>@stryker-mutator/mocha-framework</del></li><li><del>@stryker-mutator/babel-transpiler</del></li><li><del>@stryker-mutator/webpack-transpiler</del></li><li><del>@stryker-mutator/javascript-mutator</del></li></ul><p>You can remove these from your package.json.</p><h2>üëΩ Mutation switching</h2><p>Mutation switching is a way to put all mutants into your code simultaneously.</p><p>Let&#x27;s take a look at an example.</p><pre><code class="language-js">function add(a, b) {
  return a + b;
}
</code></pre><p>When you feed this code to Stryker, it will generate two mutants:</p><p><code>üëΩ function add(a, b) { return a - b }</code><br/>
<code>üëæ function add(a, b) {}</code></p><p>Previous versions of Stryker would make two copies of your source code. One for each mutant. Stryker 4.0 will now place <em>all mutants into the code simultaneously</em>, but with only <em>one mutant active at any one time</em>.</p><pre><code class="language-js">function add(a, b) {
  if (global.activeMutant === 0) {
    // üëæ
  } else {
    return global.activeMutant === 1
      ? a - b // üëΩ
      : a + b;
  }
}
</code></pre><p>(simplified example)</p><p>Stryker now runs your tests while changing (or <em>switching</em>) the active mutant between runs. Mutation switching can improve performance dramatically, depending on the type of project.</p><p>You&#x27;re probably wondering: how much performance improvement? Like all great questions, the answer is: &#x27;it depends&#x27;. For example, when you bundle your code with webpack before running the tests, then webpack only needs to run once, a significant performance gain. On the other hand, if you&#x27;re running Stryker on an ES5 project with mocha, the improvement might not be that substantial. In our experience, you can expect somewhere between 20% to 70% speed increase.</p><h2>üê† Code instrumentation</h2><p>Mutation Switching yields a significant performance improvement, but it means that Stryker is required to perform some complex transformations to the <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree (AST)</a>.</p><p>Doing this <em>instrumentation</em> means visiting each node of the AST to collect and place mutants. This instrumentation is implemented with the <a href="https://babeljs.io/">Babel</a> parser and now ships with <code>@stryker-mutator/core</code>. We&#x27;re taking advantage of Babel&#x27;s support for all types of JavaScript, including TypeScript code.</p><p><em>Note that to implement mutation switching in both TypeScript and JavaScript before the release of Babel v7 would have meant implementing it twice. We think it is incredible that the Babel maintainers chose to add TypeScript support. We&#x27;re standing on the shoulders of giants here üéâ. Without this, we probably wouldn&#x27;t have done it.</em></p><p>This instrumentation means you <em>no longer need to configure the mutator</em> in your Stryker configuration. Stryker will always use the new mutation instrumenter. It supports TypeScript, JavaScript, Flow, and JSX. It even mutates script tags in <code>.html</code> or <code>.vue</code> files. It also picks up your babel configuration out-of-the-box, so no custom configuration is needed‚Äîcupcakes for everyone üßÅ.</p><h2>üë∑‚Äç‚Äç Build command support</h2><p><em>Note: not all projects need building. Simple projects might deploy JS code as is, or the test runner might take care of this step for you. For example, running your tests with ts-node or babel/register or running it with Jest or Karma with the webpack plugin.</em></p><p>Previous versions of Stryker allowed you to configure a transpiler. For example, configuring <code>&quot;transpilers&quot;: [&quot;babel&quot;]</code> would allow all files to be transpiled with the <code>@stryker-mutator/babel-transpiler</code> plugin. This way of working had its disadvantages:</p><ul><li>‚õî Since every mutant needed to transpiled one by one, it was slow.</li><li>‚õî Every transpiler/bundler required a plugin. We only officially supported Webpack, Babel, and TypeScript. If you were using a different tool, you were out of luck.</li><li>‚õî It was hard to maintain the transpiler plugins since it hooked into the transpiler/bundler&#x27;s API.</li></ul><p>Stryker 4.0 gets rid of the transpiler plugins. Instead, it allows you to configure a <code>buildCommand</code>. Stryker will run this command once in the sandbox directory after instrumenting your code and just before starting the dry run. For example, running Stryker with <code>--buildCommand &quot;npm run build&quot;</code> will run <code>npm run build</code> inside the sandbox directory.</p><p>This new way of working gets rid of all the disadvantages listed above. It will only run once, you can use whichever tool you want, and we don&#x27;t have to maintain plugins‚Äîa win-win-win scenario. The old transpiler plugins are no longer needed, and you can remove them from your project.</p><h2>‚úÖ Checker plugin</h2><p>You might know that the old <code>@stryker-mutator/typescript</code> transpiler not only transpiled your code but also filtered out mutants that resulted in type errors, marking them with &quot;compile error&quot; in your report. Mutants with this status are considered invalid and do not influence your mutation score.</p><p>Stryker 4.0 removes the transpiler plugin in favor of <code>--buildCommand</code>.</p><p><em>Wondering how your TypeScript code compiles even while some mutants might create type errors? Stryker places <code>// @ts-nocheck</code> atop your code files. Your TypeScript compiler will ignore any type errors produced by instrumenting your code.</em></p><p>However, you might still want to invalidate mutants that result in a type error, so you won&#x27;t spend any time looking at them. The new &quot;Checker&quot; plugin helps you here. Checker plugins can choose to invalidate mutants based on rules specific to the checker.</p><p>We maintain one such checker, the <code>@stryker-mutator/typescript-checker</code>. It will mark mutants that would result in a type error with &quot;Compile error&quot;.</p><p>Install it with <code>npm install -D @stryker-mutator/typescript-checker</code>.</p><p>Configure it with:</p><pre><code class="language-json">{
  &quot;checkers&quot;: [&quot;typescript&quot;],
  &quot;tsconfigFile&quot;: &quot;tsconfig.json&quot;
}
</code></pre><p>Please see <a href="https://github.com/stryker-mutator/stryker-js/tree/master/packages/typescript-checker#readme">the TypeScript checker&#x27;s readme</a> for more details.</p><h2>‚òî Coverage analysis</h2><p>Coverage analysis is a great way to speed up mutation testing. It is a means to reduce the number of tests Stryker needs to run to test a mutant. Stryker has three flavors:</p><ul><li><strong>&quot;off&quot;</strong>: No coverage analysis</li><li><strong>&quot;all&quot;</strong>: Mutant coverage for the entire test suite is measured. Mutants without coverage are marked with &quot;no coverage&quot;. But all tests run for mutants that are covered.</li><li><strong>&quot;perTest&quot;</strong>: Mutant coverage is measured per test. Stryker runs only the tests that cover a specific mutant when it tests that mutant.</li></ul><p>Running with &quot;perTest&quot; coverage analysis allows for significant performance improvement, usually between 40% and 60%. However, most projects were unable to take advantage of it because Stryker relied on <a href="https://istanbul.js.org/">istanbul code coverage</a> combined with test runner hooks. It only worked in scenarios without transpiling or bundling.</p><p>This changes with version 4. When Stryker instruments your code with mutants, it also injects the coverage instrumentation. No need for instanbul anymore, allowing Stryker to measure mutant coverage, <em>regardless of which bundler/transpiler you are using</em>. Hooking into the test runner is the only remaining requirement. All test runner plugins support these hooks, except for the <code>@stryker-mutator/jest-runner</code> (although we&#x27;re <a href="https://github.com/stryker-mutator/stryker-js/issues/2316">planning to support it</a>).</p><h2>üßπ Other changes</h2><p>We also decided to take this opportunity to improve the maintainability of the Stryker code further. That&#x27;s why we&#x27;ve decided to drop support for two more plugin types.</p><p><strong>The <code>TestFramework</code> plugins are removed.</strong></p><p>A test framework plugin used to be responsible for allowing Stryker to hook into the test framework to support &quot;perTest&quot; coverage analysis. In practice, this was often tightly coupled to the test runner itself. For example, the mocha test runner uses -you guessed it- the mocha test framework. It made configuring Stryker needlessly complicated. That&#x27;s why we&#x27;ve decided to drop this plugin type and make the Test Runner plugin responsible for hooking into the test framework directly. As a result, the following dependencies are no longer needed: <code>@stryker-mutator/mocha-framework</code> and <code>@stryker-mutator/jasmine-framework</code>.</p><p><strong>The <code>OptionsEditor</code> plugins are removed.</strong></p><p>Options editors provided a way for plugins to edit the Stryker options directly. In practice, this was used to load plugin-specific options and attach them to the StrykerOptions object for later use. Plugins should now load their needed options in their life cycle, for example, in the <code>init</code> method of the plugin.</p><h2>üí• Breaking changes</h2><p>Here is a list of the most important breaking changes. For a full list, please see our <a href="https://github.com/stryker-mutator/stryker-js/blob/master/CHANGELOG.md">changelog</a>.</p><ul><li>Configuring &quot;transpilers&quot; is no longer supported; please use <code>--buildCommand</code> instead.</li><li>Configuring <code>mutator</code> as a string, or configuring <code>mutator.name</code> is no longer supported, Stryker will always use its code instrumenter.</li><li>TypeScript 3.7 or higher is required if you&#x27;re using TypeScript to transpile your code, either via a <code>--buildCommand</code> or via a test runner plugin, like <a href="https://www.npmjs.com/package/ts-jest">ts-jest</a>, <a href="https://www.npmjs.com/package/karma-webpack">karma-webpack</a> or using the <a href="https://www.npmjs.com/package/@angular/cli">angular-cli</a>. If you&#x27;re dependent on TS &lt;3.7, please consider upgrading, or keep using Stryker V3. This is because the mutation instrumenter heavily leans on the support of <code>// @ts-nocheck</code> feature, added in TS3.7. If you&#x27;re using another transpiler, like <a href="https://babeljs.io">babel</a> or <a href="https://github.com/TypeStrong/ts-node">ts-node with <code>transpileOnly</code></a>, then Stryker will work fine.</li><li>Because of the requirement for TS 3.7, Angular &gt;=9.0 is required for Angular projects.</li><li>The <code>&quot;command&quot;</code> test runner is now &quot;best-effort&quot;. Stryker will use an environment variable to communicate which mutant should be active. Your test command should pass the environment variables to the test environment. We expect this to work for most test runners and test commands out there. One exception is Karma, but since we have the <code>@stryker-mutator/karma-runner</code> for this use case, it shouldn&#x27;t be a problem.</li><li>Support for the Web Component Tester is dropped. Please see <a href="https://github.com/stryker-mutator/stryker-js/issues/2386">#2386</a> for reasoning.</li><li>Exporting a <code>function</code> from your &quot;stryker.conf.js&quot; file is deprecated. Please export your config as an object instead, or use a stryker.conf.json file. Please see <a href="https://github.com/stryker-mutator/stryker-js/issues/2429">#2429</a> for more details.</li><li>The <code>--maxConcurrentTestRunner</code> option is now deprecated, please use <code>--concurrency</code> instead. Stryker will use this setting to determine how to scale checkers or test runner processes. Note that Stryker will no longer prevent you from configuring more than the number of logical cores in your machine, i.e., <code>--concurrency 9999</code> might be a bad idea.</li></ul><h2>üîÆ What&#x27;s next?</h2><p>Mutation switching was a considerable undertaking, but we had to do it since it allows for further performance and usability improvements. Let&#x27;s discuss some here.</p><p>All these issues align with our project goals, which we&#x27;ve published in <a href="https://github.com/stryker-mutator/stryker-js/wiki/Roadmap">our roadmap</a>.</p><p><strong>Better Jest support</strong></p><p>With mutation switching in our backpack, implementing &quot;perTest&quot; coverage analysis for Jest is now on the table, allowing Stryker to run fewer tests in total. See <a href="https://github.com/stryker-mutator/stryker-js/issues/2316">#2316</a> for more info.</p><p><strong>Hot reload</strong></p><p>Currently, Stryker will reload all code files between test runs (clearing them from the <a href="https://nodejs.org/api/modules.html#modules_require_cache">require.cache</a> or doing a full page reload with Karma). However, thanks to mutation switching, the mutated code does not have to be reloaded. Instead, we can switch the active mutant and do another test run. Mocha will be the first test runner to receive this improvement. See <a href="https://github.com/stryker-mutator/stryker-js/issues/2413">#2413</a> for more info.</p><p><strong>In place mutation</strong></p><p>Stryker currently never mutates <em>your code</em> directly. Instead, it makes a copy of it in a &quot;sandbox&quot; directory, and it mutates your code there. The reason for this should be apparent; you don&#x27;t want mutants to make there way into production.</p><p>However, in some corner cases, the simple act of copying your code to a sandbox directory makes running the tests impossible. See <a href="https://github.com/stryker-mutator/stryker-js/issues/2163">#2163</a> for some examples. To truly make Stryker work for all JavaScript projects, we will need to allow for &quot;in place&quot; mutation. Don&#x27;t worry, this will be optional, and we will make sure to let you know what Stryker is doing üßê.</p><h2>üéâ Thank you</h2><p>Back in July, we released the first beta of Stryker 4. Since then, we got loads of responses resulting in the closing of <a href="https://github.com/stryker-mutator/stryker-js/issues?q=is%3Aissue+milestone%3A4.0+is%3Aclosed">more than 40 issues</a>, some of which were pretty major üòÖ. We want to thank everyone who helped to make this release possible! In particular (in no specific order)</p><p>üåπ <a href="https://github.com/gramster">gramster</a><br/>
<!-- -->üíê<a href="https://github.com/kmdrGroch">kmdrGroch</a><br/>
<!-- -->üåº<a href="https://github.com/Lakitna">Lakitna</a><br/>
<!-- -->üåª<a href="https://github.com/brodybits">brodybits</a><br/>
<!-- -->üå∫<a href="https://github.com/Garethp">Garethp</a></p><p>You guys are incredible!</p><p>If you read through this article: thank you! You&#x27;re awesome! Now stop reading and give Stryker 4 a try. And let us know what you think üòÄ.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Announcing Stryker 4.0 Beta]]></title>
        <id>announcing-stryker-4-beta-mutation-switching</id>
        <link href="https://stryker-mutator.io/blog/announcing-stryker-4-beta-mutation-switching"/>
        <updated>2020-07-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We're excited to announce the beta of the next major release of the Stryker mutation testing framework for JavaScript and friends: Stryker 4.0.]]></summary>
        <content type="html"><![CDATA[<p>We&#x27;re excited to announce the beta of the next major release of the Stryker mutation testing framework for JavaScript and friends: Stryker 4.0.</p><p>This beta is a huge milestone because it means a fundamental shift in the way Stryker works internally. It now uses &quot;Mutation switching&quot;, a technique that can improve performance.</p><p>This, unfortunately, couldn&#x27;t be done without breaking changes. These changes are mostly limited to the internal plugin API&#x27;s except for the changes highlighted in this blog article.</p><p>To get started using the beta, update your Stryker dependencies using npm or yarn.</p><pre><code class="language-shell">npm install --save-dev @stryker-mutator/core@next
</code></pre><p>Don&#x27;t forget to update Stryker plugins. For example, when using mocha:</p><pre><code class="language-shell">npm install --save-dev @stryker-mutator/mocha-runner@next
</code></pre><p>This beta is released early, in order to get community feedback. We&#x27;ve not yet updated the docs with the changes specified in this blog article. At this moment, the jest-runner and the command test runner <em>still need to be migrated and will not work as expected</em>.</p><p><em>Note: Since beta version <code>4.0.0-beta.2</code>, both the command test runner and the jest test runner are supported. However, the command test runner does have some <a href="https://github.com/stryker-mutator/stryker-js/pull/2345">limitations</a></em></p><p>If you&#x27;re new to mutation testing, it&#x27;s a way to measure your tests&#x27; effectiveness. Please take a look at <a href="/example">our RoboBar ü§ñüç∑ example</a> and see how even 100% code coverage doesn&#x27;t tell the whole story. Mutation testing is the only way to make sure your code is thoroughly tested.</p><h2>üëΩ Mutation switching</h2><p>Mutation switching is a way to simultaneously put all mutants into your code while making sure only one mutant is active at the same time. Let&#x27;s take a look at an example.</p><p>Let&#x27;s take this.</p><pre><code class="language-js">function add(a, b) {
  return a + b;
}
</code></pre><p>When you feed this code to Stryker, it will generate two mutants:</p><p>üëΩ <code>function add(a, b) { return a - b }</code><br/>
<!-- -->üëæ <code>function add(a, b) {}</code></p><p>Previous versions of Stryker would make two copies of the source code. One for each mutant. This changes with Stryker 4.0. Both mutants will be placed into the code <em>at the same time</em>.</p><pre><code class="language-js">function add(a, b) {
  if (global.activeMutant === 0) {
  } else {
    return global.activeMutant === 1 ? a - b : a + b;
  }
}
</code></pre><p>(simplified example)</p><p>Stryker can now run your tests twice while changing which mutant is active in the process. Mutation switching can improve performance dramatically, depending on the type of project. For example, when you bundle your code with webpack before running the tests, then webpack only needs to run once. The same goes for TypeScript projects where you compile your code before testing.</p><h2>üê† Instrumentation with Babel</h2><p>Mutation Switching is a significant performance improvement, but it means that Stryker is required to perform some complex transformations of the <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree (AST)</a>.</p><p>Doing this <em>instrumentation</em> means visiting each node of the AST to collect and place mutants. This instrumentation is implemented with the <a href="https://babeljs.io/">Babel</a> parser and now ships with <code>@stryker-mutator/core</code>. We&#x27;re taking advantage of Babel 7&#x27;s support to parse and print any type of JavaScript, including TypeScript code.</p><p>This means that it is <em>no longer needed to configure the <code>mutator</code></em> in your Stryker configuration. Stryker will always use the new mutation instrumenter. It supports TypeScript, JavaScript, Flow, and JSX. It even supports mutating script tags in <code>.html</code> or <code>.vue</code> files. It also picks up your babel configuration out-of-the-box, so no custom configuration is needed.</p><h2>üë∑‚Äç‚Äç Build command support</h2><p>With mutation switching, all mutants are placed in the code at the same time. This also means that it only has to be built (transpiled or bundled) once.</p><p><em>Note: not all projects need building. Simple projects might deploy JS code as is, or the test runner might take care of this step for you. For example, running your tests with <code>ts-node</code> or <code>babel/register</code> or running it with <code>Jest</code> or <code>Karma</code> with the <a href="https://github.com/webpack-contrib/karma-webpack">webpack plugin</a>.</em></p><p>Before mutation switching, this would be the job of the <code>transpiler</code> plugin type. For example, <code>transpiler: [&#x27;babel&#x27;]</code> would mean that all files would be transpiled with the <code>@stryker-mutator/babel-transpiler</code> plugin. It was a bit complex to create a transpiler plugin, and since every mutant needed to transpiled, it was slow. Every transpiler/bundler needed its a transpiler plugin.</p><p>Stryker 4.0 will no longer support the <code>transpiler</code> plugins. Instead, it allows you to configure a <code>buildCommand</code> yourself. A build command can be any command. Some examples include <code>npm run build</code>, <code>tsc -b</code> or <code>webpack --config webpack.config</code>. This means that the available plugins do not limit you.</p><p>The following dependencies are therefore no longer needed, and you can simply remove them:</p><ul><li><code>@stryker-mutator/babel-transpiler</code></li><li><code>@stryker-mutator/webpack-transpiler</code></li><li><code>@stryker-mutator/typescript</code></li></ul><h2>‚úÖ Checker plugin</h2><p>You might know that the old <code>@stryker-mutator/typescript</code> transpiler not only transpiled your code but also filtered out mutants that resulted in type errors, marking them with <code>compile error</code> (or <code>transpile error</code>) in your report. Mutants with this status are marked as &quot;invalid&quot; and do not influence your mutation score.</p><p>Since Stryker 4.0 <a href="#build-command-support">removes the transpiler plugin type</a> we needed a new plugin that can perform this type checking. Introducing the <code>Checker</code> plugin type. In the Stryker 4 release, we will include one such checkers, the <code>@stryker-mutator/typescript-checker</code>.</p><p>Install it with <code>npm install @stryker-mutator/typescript-checker@next</code></p><p>Configure it with:</p><pre><code class="language-ts">{
  &quot;checkers&quot;: [&quot;typescript&quot;],
  &quot;tsconfigFile&quot;: &quot;tsconfig.json&quot;
}
</code></pre><p>(tsconfig.json is the default setting for &quot;tsconfigFile&quot;).</p><p>Please see <a href="https://github.com/stryker-mutator/stryker-js/tree/epic/mutation-switching/packages/typescript-checker#readme">the TypeScript checker&#x27;s readme for more details</a></p><h2>‚òî More coverage analysis</h2><p>Coverage analysis is a way to speed up mutation testing. Stryker always came with three flavors:</p><ul><li>&quot;off&quot;: No coverage analysis</li><li>&quot;all&quot;: Coverage is measured for the entire test suite. Mutants that are not covered by even one test are marked with &quot;NoCoverage&quot;</li><li>&quot;perTest&quot;: Coverage is measured per test. Only tests that cover a specific mutant are run for that mutant.</li></ul><p>Running with &quot;perTest&quot; coverage yields a significant performance improvement (usually between 40% and 60%). However, most projects were unable to take advantage of it because Stryker relied on a complex mechanism of <a href="https://istanbul.js.org/">istanbul</a> code coverage combined with hooks in the test runner. It only worked in scenarios without complicated transpiling or bundling.</p><p>With the introduction of mutation switching, the instrumenter is responsible for inserting coverage instrumentation into the code. This means that Stryker can measure mutant coverage, <em>regardless of which bundler/transpiler you are using</em>. The only requirement is that Stryker needs to be able to hook into the test runner. This is currently supported for <code>@stryker-mutator/mocha-runner</code>, <code>@stryker-mutator/karma-runner</code> and <code>@stryker-mutator/jasmine-runner</code>. Support for <a href="https://github.com/stryker-mutator/stryker-js/issues/2316"><code>@stryker-mutator/jest-runner</code> is planned</a>.</p><h2>üßπ Other changes</h2><p>We also decided to take this opportunity to improve the maintainability of the Stryker code further. That&#x27;s why we&#x27;ve decided to drop support for two more plugin types.</p><ul><li>The <code>TestFramework</code> plugin type is removed<br/>A test framework plugin used to be responsible for allowing Stryker to hook into the test framework to implement test filtering and perTest coverage analysis. In practice, this was often tightly coupled to the test runner itself. That&#x27;s why we&#x27;ve decided to drop this plugin type and make the Test Runner plugin responsible for hooking into the test framework directly. Therefore the following dependencies can simply be removed: <code>@stryker-mutator/mocha-framework</code> and <code>@stryker-mutator/jasmine-framework</code>.</li><li>The <code>OptionsEditor</code> plugin type is removed<br/>Options editors provided a way for plugins to edit the Stryker options directly. In practice, this was used to load plugin-specific options and attach them to the StrykerOptions object for later use. Plugins are now expected to load their options in their life cycle.</li></ul><h2>üîÆ What&#x27;s next</h2><p>We&#x27;ll be focussing on getting Stryker 4.0 released. For that to happen, we would appreciate your feedback. Feel free to report any <a href="https://github.com/stryker-mutator/stryker-js/issues/new">issues</a> you have with this beta release.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Integrating Stryker.NET in your azure pipelines]]></title>
        <id>azure-pipelines-integration</id>
        <link href="https://stryker-mutator.io/blog/azure-pipelines-integration"/>
        <updated>2020-05-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Over the past few months we have been working hard to integrate Stryker.NET with azure pipelines. Learn how you can leverage our new features to include mutation testing in your continuous integration.]]></summary>
        <content type="html"><![CDATA[<p>Over the past few months we have been working hard to integrate Stryker.NET with azure pipelines. Learn how you can leverage our new features to include mutation testing in your continuous integration.</p><p>When using continuous integration it can be hard to keep track of quality. By integrating Stryker in your build pipelines you can ensure a continued focus on test quality, no matter how many changes your code gets to see.</p><h2>üöÄ Speed</h2><p>Stryker.NET is now faster than ever! This means you can run mutation testing for every pull request without waiting too long for your build to succeed.</p><p>Some performance improvements we have implemented:</p><ul><li>Mutation switching<ul><li>We compile all mutants at once using conditional statements around the mutations. When testing the mutants we only have to flip the switch to turn it on üîõ</li></ul></li><li>Integration with VSTest<ul><li>This is the fastest way to run your tests. And VSTest supports all well known test frameworks.</li></ul></li><li>Coverage analysis<ul><li>We do not test mutants that are not covered by any test. And we only run the tests that cover the mutant when testing that mutant.</li></ul></li><li>Testing mutants in parallel<ul><li>We run multiple test sessions at once to test the mutants even faster.</li></ul></li><li>Using the same test session for non overlapping mutants<ul><li>Mutants that are in a different file and have no overlapping covered tests are run in the same test session to remove the overhead of starting a new test session.</li></ul></li></ul><p>By implementing all these performance tweaks we can now proudly say we are fast enough to use in your pipeline! So if performance was holding you back, now is the moment to give Stryker.NET a try! üöÄ</p><h2>üîé Git integration</h2><p>On large projects we can also use git to filter changed files in a pull request. That way only the changed code will be mutated. This helps to use mutation testing in pull request even on the largest projects.</p><p>How does this work? Simply run Stryker.NET with the following command in your PR build:</p><pre><code>dotnet stryker --diff
</code></pre><p>This will use the master branch as base by default. If you use a different branch as base for your pull requests you can change the base branch like this:</p><pre><code>dotnet stryker --diff --git-source &quot;coalesce(variables[&#x27;System.PullRequest.TargetBranch&#x27;], variables[&#x27;Build.SourceBranchName&#x27;])&quot;
</code></pre><p>This will get the pull request target branch, or the build source branch if no pull request target branch is available.</p><p>üí° Tip:
You can use this feature locally too, if you want to quickly mutate your new feature.</p><h2>‚ú® Reporting</h2><p>Another feature we are proud of is our integration with azure devops.</p><p>You can now display the html report in your azure devops environment using an <a href="https://marketplace.visualstudio.com/items?itemName=stryker-mutator.mutation-report-publisher">azure devops extension</a>.</p><p><img src="/images/blogs/azure-devops-extension1.png"/></p><p><img src="/images/blogs/azure-devops-extension3.png"/></p><p>The extension will add a new tab to your build result page. This new tab will contain the full html report that is also available locally and on the stryker dashboard.</p><p>How to use the extension:</p><ul><li>Install the <a href="https://marketplace.visualstudio.com/items?itemName=stryker-mutator.mutation-report-publisher">extension</a> on your azure devops environment</li><li>Run <code>dotnet stryker</code> in your pipeline.</li><li>Make sure the <code>html reporter</code> is enabled (default).</li><li>Add the <code>publish mutation report</code> task to your pipeline (after <code>dotnet stryker</code>)</li><li>Pass the path to the html report</li></ul><p>Example:
<img src="/images/blogs/azure-devops-extension2.png"/></p><p>üí° Note: The extension does work for other mutation test frameworks as well. As long as the framework outputs a html report and you provide the location to the task, it will be displayed in your build result tab.</p><h2>‚õî Forcing test quality</h2><p>It&#x27;s great that it is now possible to monitor the test quality automatically. But if you want to take a step even further towards maintaining your test quality you can set a breaking threshold.</p><p>This will break your pipeline if a minimum mutation score wasn&#x27;t reached.</p><p>How to use custom thresholds:</p><pre><code>dotnet stryker --threshold-high 90 --threshold-low 75 --threshold-break 60
</code></pre><p>or in <code>stryker-config.json</code></p><pre><code>{
    &quot;stryker-config&quot;:
    {
        &quot;threshold-high&quot;: 90,
        &quot;threshold-low&quot;: 75,
        &quot;threshold-break&quot;: 60
    }
}
</code></pre><p>This will make Stryker return a non-zero exit code when the mutation score is below 60.</p><p><img src="/images/blogs/threshold-break.png"/></p><p>üí° Tip:
If you think your mutation score is too low, try to increase the threshold every few months to gradually improve your tests.</p><p>üí° Tip:
If you can&#x27;t seem to kill a mutant, maybe the mutated code is not needed and can be safely removed.</p><h2>üéÜ Conclusion</h2><p>With all these features nothing stands in your way to go and add Stryker.NET to your build pipeline.</p><p>If we put all these features together your pipeline could look like this:</p><pre><code class="language-yaml">steps:
- task: UseDotNet@2
displayName: &#x27;Use .Net Core runtime 3.1.x&#x27;
inputs:
    packageType: runtime
    version: 3.1.x
- task: DotNetCoreCLI@2
displayName: &#x27;Install dotnet tools for Stryker.CLI&#x27;
inputs:
    command: custom
    custom: &#x27;tool restore&#x27;
    workingDirectory: &#x27;src\Stryker.CLI\Stryker.CLI.UnitTest&#x27;
- task: DotNetCoreCLI@2
displayName: &#x27;Run stryker on Stryker.CLI&#x27;
inputs:
    command: custom
    custom: &#x27;stryker --reporters &quot;[&#x27;&#x27;dashboard&#x27;&#x27;, &#x27;&#x27;html&#x27;&#x27;]&quot; --threshold-high 90 --threshold-low 75 --threshold-break 60 --diff&#x27;
    workingDirectory: &#x27;src\Stryker.CLI\Stryker.CLI.UnitTest&#x27;
- task: stryker-mutator.mutation-report-publisher.publish-mutation-report.publish-mutation-report@0
displayName: &#x27;Publish Mutation Test Report&#x27;
inputs:
    reportPattern: &#x27;src\Stryker.CLI\Stryker.CLI.UnitTest\**\mutation-report.html&#x27;
</code></pre><p>If you run into trouble during installation or running, please let us know so we can improve.</p><h2>üîÆ What&#x27;s next?</h2><p>The upcoming months you can expect even more awesome features and improvements in Stryker.NET.</p><ul><li>The <code>git diff</code> feature will be greatly improved and result in a full report.</li><li>Regex mutator (never seen before in mutation testing)</li><li>Mutating a whole solution at once</li></ul><p>Want to help make Stryker even better? Check out our <a href="https://github.com/stryker-mutator/stryker-net/issues">open issues</a>. Or help with implementing <a href="https://github.com/stryker-mutator/stryker-js/issues/1514">mutation switching for Stryker (js)</a></p>]]></content>
        <author>
            <name>Richard Werkman</name>
            <uri>https://github.com/richardwerkman</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Announcing Stryker 100% mode]]></title>
        <id>announcing-100-mode</id>
        <link href="https://stryker-mutator.io/blog/announcing-100-mode"/>
        <updated>2020-04-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Over the years, we've been privileged to explain the concept of Mutation Testing to great developers, testers and others.]]></summary>
        <content type="html"><![CDATA[<p>Over the years, we&#x27;ve been privileged to explain the concept of Mutation Testing to great developers, testers and others.
The concept of <em>inserting bugs into your production code</em> in order to <em>test your tests</em> sparks the imagination.</p><p>But when people start using mutation testing in practice, they
quickly realize that things are not as easy as they seem.
One of the most common questions is: &quot;what &#x27;mutation score&#x27; is good enough&quot;?
Our general advice is not to strive for 100%. But should you use 80%? Or some other percentage?
Some users just want to see that everything is great with their tests.</p><p>That&#x27;s why we&#x27;re introducing a new &#x27;100%&#x27; mode!
With this mode, Stryker itself will strive to improve your mutation score to be 100%.
You can activate it with the <code>--100</code> command line flag,
but we&#x27;re thinking of making this the default mode.</p><h2>üôâ An example</h2><p>A picture says more than a thousand words. First without the new <code>--100</code> mode:</p><p><img src="/images/blogs/stryker-without-100-mode.png"/></p><p>And now with the new <code>--100</code> mode:</p><p><img src="/images/blogs/stryker-with-100-mode.png"/></p><p>As you can see, this new mode makes for a far better-looking report!</p><p>And things just keep getting better. Since all mutants will be <em>killed - no matter what</em>, you&#x27;ll not have to wait long,
because Stryker can internally optimize the process to <em>not do actual testing whatsoever</em>. A huge performance gain!</p><h2>üîÆ What&#x27;s next?</h2><p>Seeing as this is such an obvious improvement, it will not take long for other mutation testing frameworks
to follow suit. That&#x27;s why it&#x27;s only a matter of time before
the legendary <a href="https://github.com/mull-project/mull#mull">Mull</a>,
<a href="https://infection.github.io/guide/">InfectionPHP</a> and <a href="https://pitest.org/">Pitest</a> will have this new and very important feature.</p><p>Don&#x27;t hesitate to open an issue if this important mode is missing.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Announcing Stryker 3.0]]></title>
        <id>stryker-version-3</id>
        <link href="https://stryker-mutator.io/blog/stryker-version-3"/>
        <updated>2020-03-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[With version 3 of Stryker, we've been focussing on usability. We also did some smaller changes worth pointing out.]]></summary>
        <content type="html"><![CDATA[<p>With version 3 of Stryker, we&#x27;ve been focussing on usability. We also did some smaller changes worth pointing out.
For a full list of changes, please read <a href="https://github.com/stryker-mutator/stryker-js/blob/master/CHANGELOG.md#300-2020-03-11">our changelog</a>.</p><p>If you&#x27;re new to mutation testing, it&#x27;s a way to measure how effective your tests are at finding bugs.
Please take a look at <a href="/example">our RoboBar ü§ñüç∑ example</a> and see how even 100% code coverage doesn&#x27;t tell the whole story.
Mutation testing is the only way to make sure your code is tested.</p><h2>üöÄ Migration</h2><p>Migrating to the latest major version is easy! Just update all <code>@stryker-mutator</code> dependencies to at least 3.0.0.
Please note that Node 8 is <em>no longer supported</em>. For other breaking changes, please read the <a href="#breaking-changes">üî• Breaking changes</a></p><p>If you&#x27;re new to Stryker, please see <a href="/stryker/quickstart">our quickstart</a>. Have fun with mutation testing!</p><h2>üìÉ New config format</h2><p>We&#x27;ve always supported a stryker.conf.js file for your Stryker options.
In that file, you had to export a function that would be executed by Stryker
in which you could set your config options.</p><p>Although this is still allowed, it is unnecessarily complex. That&#x27;s why Stryker now supports direct
object exports.</p><pre><code class="language-js">module.exports = {
  // Stryker config here
};
</code></pre><p>Stryker also doesn&#x27;t force the <code>.js</code> extension anymore. This allows you to write your
config in a <code>stryker.conf.json</code> file (or, if you&#x27;re feeling adventures, you could also
use something like <a href="https://github.com/TypeStrong/ts-node">ts-node</a> or <a href="https://coffeescript.org/#nodejs-usage">CoffeeScript/register</a> to use other file formats).</p><h2>üëì IntelliSense in configuration</h2><p>With the rising popularity of <a href="https://json-schema.org/">JSON schema</a>
(and the code editors supporting it) it&#x27;s more common to use JSON files for configuration. That&#x27;s why we now also support
the <code>stryker.conf.json</code> format. By pointing the <code>$schema</code> key to <a href="https://raw.githubusercontent.com/stryker-mutator/stryker/master/packages/api/schema/stryker-core.json">our <code>stryker-core.json</code> schema file</a>, you&#x27;ll be able to get IntelliSense
in your code editor of choice.</p><p><img src="/images/blogs/intellisense.png" alt="IntelliSense"/></p><p>This now also the default generated by <code>npx stryker init</code>.</p><p>If you still want to use the JS file format, it is also possible to get IntelliSense,
as long as your editor supports TypeScript notation in JSDoc.</p><pre><code class="language-js">/**
 * @type {import(&#x27;@stryker-mutator/api/core&#x27;).StrykerOptions}
 */
module.exports = {
  // IntelliSense here!
};
</code></pre><h2>üé® HTML reporter by default</h2><p>We&#x27;ve noticed that most developers like the HTML reporter a lot.
However, it was always a separate package. This was originally done
because it depended on a somewhat expensive template library (namely <a href="https://handlebarsjs.com/">handlebars</a>).
Since the release of the <a href="/blog/2019-04-03/one-mutation-testing-html-report">mutation testing HTML report</a>,
this is no longer the case.</p><p>That&#x27;s why Stryker now comes with the HTML reporter included. It is also enabled by default. You can still disable it
by overriding the <code>&quot;reporters&quot;</code> property manually.</p><h2>üî• Breaking changes</h2><p>This major release comes with some breaking changes:</p><ol><li><strong>Platform</strong><ul><li><a href="https://github.com/stryker-mutator/stryker-js/pull/2028">#2028</a> NodeJS version 10 or higher is now required to run Stryker.</li></ul></li><li><strong>Core</strong><ul><li><a href="https://github.com/stryker-mutator/stryker-js/issues/1996">#1996</a> Always exit with exit code 1 if an error of any kind occurs (previously there were scenarios where it didn&#x27;t fail).</li><li><a href="https://github.com/stryker-mutator/stryker-js/pull/2039">#2039</a> The Dashboard reporter (if enabled) will now default to uploading the full report.</li></ul></li><li><strong>HTML Reporter</strong><ul><li><a href="https://github.com/stryker-mutator/stryker-js/pull/2036">#2036</a> The HTML reporter is now included in the Stryker core. You should remove the dependency on <code>&quot;@stryker-mutator/html-reporter&quot;</code>.
Please override the <code>&quot;reporters&quot;</code> option to disable the reporter.</li></ul></li><li><strong>Karma runner</strong><ul><li><a href="https://github.com/stryker-mutator/stryker-js/pull/2048">#2048</a> Always run with <code>client.clearContext</code> to prevent a race condition.</li><li><a href="https://github.com/stryker-mutator/stryker-js/pull/2035">#2035</a> Use <code>ChromeHeadless</code> by default instead of <code>PhantomJS</code>.</li></ul></li></ol>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Host your mutation testing report]]></title>
        <id>stryker-dashboard-host-your-mutation-testing-report</id>
        <link href="https://stryker-mutator.io/blog/stryker-dashboard-host-your-mutation-testing-report"/>
        <updated>2019-12-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[üìä The Stryker Dashboard can now host your mutation testing report in the cloud.]]></summary>
        <content type="html"><![CDATA[<p>üìä The Stryker Dashboard can now host your mutation testing report in the cloud.</p><p>If you&#x27;re new to mutation testing, it&#x27;s a way to measure how effective your tests are at finding bugs.
Please take a look at <a href="/example">our RoboBar ü§ñüç∑ example</a> and see how even 100% code coverage doesn&#x27;t tell the whole story.
Mutation testing is the only way to make sure your code is tested.</p><p>Mutation testing is done by a mutation testing framework. After a mutation test run, you&#x27;ll get a report that gives you all the details.
Since mutation testing is still growing in popularity, there wasn&#x27;t a convenient way yet to view the report in the cloud.
The Stryker Dashboard solves that problem.</p><p>The dashboard now has several new features:</p><p>üíÑ Store and show gorgeous reports.<br/>
<!-- -->ü•á Brag about your mutation score with the mutation score badge.<br/>
<!-- -->üîÄ Support for Git workflows with mutation reports per branch and tag.<br/>
<!-- -->üêâ Support for Monorepos. Multiple reports are aggregated to show a report of all your modules.<br/>
<!-- -->üí∏ Free for open source projects.<br/>
<!-- -->ü§ù Supports all Stryker mutation testing frameworks. Other frameworks will add support over time or you can send your report through a cURL request. See <a href="https://github.com/stryker-mutator/stryker-handbook/blob/master/dashboard.md">the Stryker handbook</a> for more details.</p><h2>Some examples</h2><p>Click on the links below to see some examples of mutation testing reports hosted in the Stryker Dashboard.</p><ul><li><a href="https://dashboard.stryker-mutator.io/reports/github.com/stryker-mutator/stryker-js/master">Stryker <img src="https://img.shields.io/endpoint?style=flat&amp;url=https%3A%2F%2Fbadge-api.stryker-mutator.io%2Fgithub.com%2Fstryker-mutator%2Fstryker%2Fmaster" alt="badge"/></a></li><li><a href="https://dashboard.stryker-mutator.io/reports/github.com/stryker-mutator/stryker4s/master">Stryker4s <img src="https://img.shields.io/endpoint?style=flat&amp;url=https%3A%2F%2Fbadge-api.stryker-mutator.io%2Fgithub.com%2Fstryker-mutator%2Fstryker4s%2Fmaster" alt="badge"/></a></li><li><a href="https://dashboard.stryker-mutator.io/reports/github.com/stryker-mutator/stryker-net/master">Stryker.NET <img src="https://img.shields.io/endpoint?style=flat&amp;url=https%3A%2F%2Fbadge-api.stryker-mutator.io%2Fgithub.com%2Fstryker-mutator%2Fstryker-net%2Fmaster" alt="badge"/></a></li></ul><h2>Why do we need it?</h2><p>Mutation testing can be time-consuming.
Using your PC to do it is fine for small projects, but for bigger projects, you really want to run it in your CI/CD pipeline.</p><p>This is also something we&#x27;ve experienced developing Stryker, the mutation testing framework for JavaScript and TypeScript.
At first, we would run Stryker on Stryker every week.
But as our codebase grew, this became impractical.</p><p>Luckily, running mutation testing in your CI/CD pipeline is a trivial task.
Most mutation testing frameworks can be run from the command line.
This is also true for the Stryker family of frameworks.</p><p>The problem becomes: what is a convenient way to read the mutation testing report üëÄ?
Manually downloading files and opening them in your browser isn&#x27;t a way anyone should be forced to spend an afternoon.</p><h2>Where can I get my own?</h2><p>Getting up and running with the dashboard is simple.</p><p>üéØ Navigate to <a href="https://dashboard.stryker-mutator.io">dashboard.stryker-mutator.io</a> and log in with your GitHub account.<br/>
<!-- -->‚úÖ Enable the Stryker Dashboard for your repository.<br/>
<!-- -->üîë Configure your API key. See <a href="https://github.com/stryker-mutator/stryker-handbook/blob/master/dashboard.md">the dashboard article on the Stryker handbook for the details</a><br/>
<!-- -->üèÉ‚Äç‚ôÄÔ∏è Run Stryker.NET, Stryker4s or Stryker (with the dashboard reporter enabled) and upload your first report.</p><h2>Eating our own dog food üç¥üê∂ü•´</h2><p>We are eating our own dog food since we&#x27;re using the new dashboard features to make our own mutation testing reports visible.
We&#x27;re naturally welcoming pull requests to help improve our tests.
Improving tests is a good way to get to know a new codebase.</p><h2>What&#x27;s next?</h2><p>We can&#x27;t wait for people to start using the dashboard and give feedback.
Please enable it on your open-source project and tell us what you think!
Together, we&#x27;ll be able to spread the word about mutation testing
and test quality by making it more visible</p><p>We&#x27;d like to get more mutation testing frameworks on board. To this date, <a href="https://twitter.com/maks_rafalko/status/1207256423404638208">InfectionPHP</a> for PHP,
<a href="https://twitter.com/1101_debian/status/1206613696564346881">Mull</a> for C++ and <a href="https://twitter.com/_pitest/status/1207251028653068288">Pitest</a> for Java
have shown interest.</p><p>We&#x27;re looking to improve the dashboard further. You can expect more features and open-source git providers to be added.
We&#x27;re always looking for feedback, please don&#x27;t hesitate to create <a href="https://github.com/stryker-mutator/stryker-dashboard/issues/new">an issue</a>.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Announcing Stryker 2.0]]></title>
        <id>announcing-stryker-2-0</id>
        <link href="https://stryker-mutator.io/blog/announcing-stryker-2-0"/>
        <updated>2019-05-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A new major version of Stryker for JavaScript and TypeScript has been released: version 2.0.0.]]></summary>
        <content type="html"><![CDATA[<p>A new major version of Stryker for JavaScript and TypeScript has been released: version 2.0.0.
This blog post will cover some of the changes. For a full list of changes, please read <a href="https://github.com/stryker-mutator/stryker-js/blob/master/CHANGELOG.md#200-2019-05-17">our changelog</a>.</p><p>If you run into any issues using the latest version of Stryker, please let us know!</p><h2>üöÄ Migration</h2><p>Migrating to the latest major version is easy! Just update all <code>@stryker-mutator</code> dependencies to at least version 2.0.0. If you are still using version 0.x.x, then please look at <a href="https://stryker-mutator.io/blog/2019-02-13/announcing-stryker-1-0">our blog post regarding stryker v1</a>.</p><p>If you&#x27;re new to Stryker, please see <a href="/stryker/quickstart">our quickstart</a>. Have fun with mutation testing!</p><h2>üî• Breaking changes</h2><p>This major release comes with some breaking changes:</p><ol><li>NodeJS version 8 or higher is now required to run Stryker</li><li>The code of Stryker is now es2017 code instead of es5</li></ol><h2>‚ú® What&#x27;s new</h2><p>Not a big list of new features this time around. Mainly housekeeping and other optimizations. Here you&#x27;ll find a list of small improvements.</p><ul><li>Prettier has been removed as a direct dependency. We use prettier when initially writing your stryker.conf.js to disk (with <code>stryker init</code>).
We now run prettier using the npx command instead of packaging it with Stryker, keeping Stryker lean and mean.</li><li>We&#x27;ve updated our source-map dependency to enable lazy loading. This ensures that coverage data is only mapped when (and if) it&#x27;s required.</li><li>VueJS files are only mutated when they contain <code>&lt;script&gt;</code> blocks.</li></ul><h2>üë¥ Deprecations</h2><p>Since Stryker v1, we&#x27;ve introduced a deprecation policy. This means that we&#x27;ll support features for one major release after we&#x27;ve deprecated them.
This is a (small) list of stuff we&#x27;ve deprecated. You&#x27;ll also get a warning if you still use them in your setup.</p><ul><li>The use of mocha version 5 and below is deprecated. This is mainly because of big changes the way you configure mocha.
Please upgrade to mocha 6 or above. See <a href="https://github.com/mochajs/mocha/blob/master/CHANGELOG.md#600--2019-02-18">their changelog</a> for more information about upgrading.
Support for mocha version 5 and below will be removed in the future (with Stryker v3 probably).</li><li>The <code>onScoreCalculated</code> internal reporter event is deprecated. Please use <code>onMutationTestReportReady</code> and calculate the score using <a href="https://github.com/stryker-mutator/mutation-testing-elements/tree/master/packages/mutation-testing-metrics#readme">mutation-testing-metrics</a>.
All reporters maintained by the Stryker team are already migrated.</li></ul><h2>üìÖ Release schedule</h2><p>We&#x27;ll keep improving Stryker by fixing nasty bugs, improving code (and test) quality and by adding new features.
The next major release of Stryker will probably be at the start of 2020 due to the LTS support of NodeJS version 8 ending.</p>]]></content>
        <author>
            <name>Simon de Lang</name>
            <uri>https://github.com/simondel</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Announcing Stryker.NET 0.10 with .NET Framework support]]></title>
        <id>announcing-dotnet-framework-support</id>
        <link href="https://stryker-mutator.io/blog/announcing-dotnet-framework-support"/>
        <updated>2019-04-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Stryker.NET 0.10 is here! This brings new features to mutation testing for .NET. Read all about these features in this blog.]]></summary>
        <content type="html"><![CDATA[<p>Stryker.NET 0.10 is here! This brings new features to mutation testing for .NET. Read all about these features in this blog.</p><p>Stryker.NET has been under very active development. Up to now, we focussed on performance and .NET core.
That all changes with v0.10, as we now also support <strong>.NET Framework</strong>. Both frameworks are supported now,
with 100% feature parity. We also introduce some cool new features.</p><p>In this article we want to briefly recap what mutation testing is.
After that we&#x27;ll explain how you install and use Stryker.NET.
We also want to highlight some cool new features, before we end with a quick look at what&#x27;s next.
Jump right into it:</p><h2>üëæ Mutation testing</h2><p>For those of you who might not be familiar with Stryker.NET and Mutation Testing, here is a brief reminder.
Please see <a href="/example">our RoboBar example</a> for the full introduction.</p><p>Stryker.NET places <em>mutants</em> (bugs) inside your source code. After that, it runs your tests for each mutant.
If at least one tests fails, that&#x27;s great! Your tests just killed that mutant. If not, too bad, the mutant survived.
Apparently, you&#x27;re missing a test.</p><p>Calculating the percentage of mutants that were killed results in the mutation score. The higher the number, the better.
It is the only way to measure <em>your tests effectiveness</em>. It&#x27;s really as simple as that.</p><p>To cover as much logic as possible Stryker.NET provides a wide range of mutations.
An overview of these mutations can be found <a href="../docs/stryker-net/Mutators">here</a>.
You can run Stryker.NET with .NET Core on Windows, Mac and Linux as well as .NET Framework on Windows.</p><h2>üí™ Start using Stryker.NET</h2><p>Stryker.NET is now installed as a (global) <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools">dotnet tool</a>
instead of a <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/extensibility">Per-project tool</a>.
This has the advantage of not competing with your local project dependencies, but this also means that
Stryker.NET has to be installed globally on your system. From .NET core 3.0, you will be able to install dotnet tools locally inside your project.</p><ol><li><p>Installation</p><p>Install <strong>globally</strong> (.NET Core runtime 2.2+):</p><pre><code>dotnet tool install -g dotnet-stryker
</code></pre><p>Or install <strong>locally</strong> (.NET Core runtime 3.0+):</p><pre><code class="language-shell">cd my-test-project
dotnet new tool-manifest
dotnet tool install dotnet-stryker
</code></pre><p>This will create a file called dotnet-tools.json in your project folder. You should check this file into source control to make sure all team members have access to Stryker and other tools specified here.</p><pre><code>dotnet tool install dotnet-stryker
</code></pre></li><li><p>Install NuGet</p><p>For .NET Core projects this step can be skipped.<br/>
<!-- -->For .NET Framework projects, make sure <code>nuget.exe</code> is installed on your system.
Please follow their <a href="https://docs.microsoft.com/en-us/nuget/install-nuget-client-tools#windows">installation instructions</a>.</p></li><li><p>Remove old references</p><p>Remove the old <code>DotNetCliToolReference</code> from your test project since they won&#x27;t be updated anymore.</p></li><li><p>Have fun using stryker!</p><p>You can now kick off stryker using</p><pre><code>dotnet stryker --solution-path &quot;../MySolution.sln&quot;
</code></pre><p>If stryker is installed as a dotnet core 3.0 local tool, use the following instead:</p><pre><code>dotnet tool run dotnet-stryker --solution-path &quot;../MySolution.sln&quot;
</code></pre></li></ol><h2>‚è© VSTest integration</h2><p>Stryker.NET now hooks right into VSTest to execute your unit tests instead of running your tests from the command line.
This means a big performance boost, because it keeps the VSTest connection alive between test runs.
Because Stryker.NET supports VSTest, this performance boost wil work for most test frameworks, including <a href="https://xunit.github.io/">XUnit</a>,
<a href="https://nunit.org/">NUnit</a> and <a href="https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-mstest">MSTest</a>.</p><h2>üìä New HTML report</h2><p>This might catch your eye. As of v0.10, Stryker.NET comes with an HTML reporter.
It shows a report in your browser with insights in your test quality, directly after your run Stryker.<br/>
<!-- -->It even goes into detail and shows you exactly what mutants were made and if your tests killed them!</p><p><img src="/images/stryker-net/html-report-net.png"/></p><p>It uses the generic <a href="https://github.com/stryker-mutator/mutation-testing-elements">mutation-testing-elements</a>,
which is an open standard for reporting mutation test results. See our <a href="./2019-04-03-one-mutation-testing-html-report.md">previous blog</a> for more information about the mutation-testing-elements</p><h2>üèÉ‚Äç Progress bar</h2><p>You can now track the progress of the mutation testing process, as well as preview the mutant stats.
It also includes an indication of the remaining time to finish.
<img src="/images/stryker-net/progress-bar-net.png"/></p><h2>üîÆ What&#x27;s next?</h2><p>The following months we will be focusing on performance and stability.
The main next feature will be coverage analysis. How does that work?</p><p>Stryker.NET will use code coverage analysis to find mutants that are not covered by your tests.
If it&#x27;s not covered, it cannot be killed by any test, right? The mutant will be marked as <code>no coverage</code>,
meaning the mutant survived while we saved valuable time.</p><h2>Contribute</h2><p>Want to help make Stryker.NET even better?
Check out our <a href="https://github.com/stryker-mutator/stryker-net/blob/master/CONTRIBUTING.md">contribution guide</a>
and <a href="https://waffle.io/stryker-mutator/stryker-net">backlog</a> to see what help we need.</p><p>Special thanks to <a href="https://github.com/stryker-mutator/stryker-net/commits?author=dupdob">@dubdop</a> for all his contributions. Keep up the good work! üí™</p>]]></content>
        <author>
            <name>Richard Werkman</name>
            <uri>https://github.com/richardwerkman</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[One mutation testing HTML report]]></title>
        <id>one-mutation-testing-html-report</id>
        <link href="https://stryker-mutator.io/blog/one-mutation-testing-html-report"/>
        <updated>2019-04-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[If you've used Stryker before, you'll know that it produces a gorgeous report you can view in the browser.]]></summary>
        <content type="html"><![CDATA[<p>If you&#x27;ve used Stryker before, you&#x27;ll know that it produces a gorgeous report you can view in the browser.
It works by generating HTML files based on the events raised by Stryker.
During development of Stryker4s and Stryker.NET, we realized that producing the same report would be a lot of
work.</p><p>Instead of a new HTML reporter implementation for each Stryker framework, we&#x27;ve decided to move the logic of presenting the report to your browser.
That way, any framework can support an HTML report simply by producing a JSON file.</p><p>We call it <a href="https://github.com/stryker-mutator/mutation-testing-elements#readme">mutation testing elements</a> and
it is implemented using the mature
<a href="https://www.w3.org/TR/components-intro/">web components suite of features</a>.
You can now use it in Stryker, Stryker.NET and Stryker4s</p><h2>üë∑‚Äç Usage</h2><p>To enable the new HTML reporter, simply update to the latest Stryker release and
enable the HTML reporter in the implementation of your choice.</p><ul><li><strong>Stryker</strong> (since v1.2)<br/>Enable by adding <code>&#x27;html&#x27;</code> to your <code>reporters</code> in your <code>stryker.conf.js</code> file.</li><li><strong>Stryker4s</strong> (since v0.3.1)<br/>Enable by adding <code>&quot;html&quot;</code> to your <code>reporters</code> in your <code>stryker4s.conf</code> file.</li><li><strong>Stryker.NET</strong> (since v0.9)<br/>Enable <code>&quot;html&quot;</code> as reporter in your <code>stryker-config.json</code> file.</li></ul><p>Upgrading should be painless.</p><h2>üí∏ Show me the money</h2><p>See two screenshots taken from a mutation testing report of Stryker itself üéâ</p><p><img src="/images/blogs/mutation-testing-elements-directory.png" alt="Directory"/></p><p><img src="/images/blogs/mutation-testing-elements-file.png" alt="File"/></p><p>Mutation testing elements comes with batteries included:</p><p>üìä Calculates and displays the mutation score and other metrics<br/>
<!-- -->üìÅ Group results into directories<br/>
<!-- -->üëì Show mutants directly in your source code<br/>
<!-- -->üòé Highlight code with embedded <a href="https://highlightjs.org/">highlightjs</a><br/>
<!-- -->üßô‚Äç Filter mutants based on the outcome<br/>
<!-- -->üîó Deep linking using anchors (uses fragment, so path will not be contaminated)<br/>
<!-- -->‚ú® A nice (yet basic) UI with embedded <a href="https://getbootstrap.com">bootstrap</a> css<br/>
<!-- -->üéì Adheres to <a href="https://developers.google.com/web/fundamentals/web-components/best-practices">custom element best practices</a></p><h2>üí≠ How it works</h2><p>Using mutation testing elements is as simple as loading the JavaScript bundle and adding
the <code>mutation-test-report-app</code> to your page, pointing the <code>src</code> to a json file that contains the
mutation testing results to be displayed.</p><pre><code class="language-html">&lt;body&gt;
  &lt;script src=&quot;https://www.unpkg.com/mutation-testing-elements@1.0.2/dist/mutation-test-elements.js&quot;&gt;&lt;/script&gt;
  &lt;mutation-test-report-app src=&quot;mutation-report.json&quot;&gt;
    Your browser does not support custom elements. Please use a modern browser.
  &lt;/mutation-test-report-app&gt;
&lt;/body&gt;
</code></pre><p>Loading from an external source (using <code>src=&quot;...&quot;</code>) only works if you serve the HTML file from a server.
Use property binding to also support opening your HTML report from disk directly.</p><pre><code class="language-js">document.querySelector(&#x27;mutation-test-report-app&#x27;).report = {
  /*... report data ...*/
};
</code></pre><p>The report json should adhere to the <a href="https://github.com/stryker-mutator/mutation-testing-elements/tree/master/packages/mutation-testing-report-schema#readme">mutation testing report json schema</a>,
we&#x27;ve designed it with this specific goal in mind.</p><p>For more information on how to use it, as well as where to find the JavaScript implementation, please see the <a href="https://github.com/stryker-mutator/mutation-testing-elements/tree/master/packages/mutation-testing-elements#readme">readme of mutation testing elements</a>
on github. Want to contribute or suggest changes? Feel free to do so in the <a href="https://github.com/stryker-mutator/mutation-testing-elements">mutation testing elements mono repo</a>.</p><h2>üí™ Call to action</h2><p>Mutation testing elements is here to help out all mutation testing frameworks.
We&#x27;ve contacted the guys over at <a href="https://infection.github.io/">Infection</a> (PHP)
and they will <a href="https://github.com/infection/infection/issues/340#issuecomment-477148001">support it in the future</a>.</p><p>If your mutation testing framework isn&#x27;t supported, why not open up an issue at their side.
Or better yet, implement it in a pull request. Most of them are open source after all.
Spread the word üíñ to help us grow üå≥.</p><h2>üîÆ What&#x27;s next?</h2><p>We&#x27;re planning to upgrade the <a href="https://dashboard.stryker-mutator.io">Stryker dashboard</a>.
Right now it already supports <a href="/blog/2018-02-08/get-your-mutation-score-badge-now">showing a mutation score badge</a>.
In the future, you will be able to host your entire mutation testing report there. Stay tuned.</p><p>Happy mutation testing!</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Announcing Stryker 1.0]]></title>
        <id>announcing-stryker-1-0</id>
        <link href="https://stryker-mutator.io/blog/announcing-stryker-1-0"/>
        <updated>2019-02-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Stryker 1.0 is here! This is an important milestone for mutation testing in JavaScript and TypeScript.]]></summary>
        <content type="html"><![CDATA[<p>Stryker 1.0 is here! This is an important milestone for mutation testing in JavaScript and TypeScript.</p><p>If you‚Äôre unfamiliar with Stryker and mutation testing, now is the perfect time to try it out!
We&#x27;ve updated <a href="/stryker/quickstart">our quickstart</a>, so go ahead and start using Stryker today.
Stryker can help you to improve your test quality by inserting bugs in your code and validating
that your tests can find them. The output is a comprehensive report telling you exactly what your unit tests missed.</p><h2>What&#x27;s new</h2><p>Here you find a list of all the new features in Stryker 1.0 (alphabetical order):</p><p><img src="/images/blogs/tumble-weed.jpg"/>
<em>Nothing to see here</em></p><p>That&#x27;s right! We chose to not introduce new features. Instead, we&#x27;ve <em>removed all deprecated functionality</em>.
Also, we&#x27;ve renamed all packages to be part of the @stryker-mutator <a href="https://docs.npmjs.com/orgs/">organization on NPM</a>.</p><h2>Migrating from Stryker 0.x</h2><p>Please use this migration guide to update your older Stryker version. If you&#x27;re feeling adventurous ü§†üêä, you can skip to step 3.</p><ol><li><p><strong>Make sure you&#x27;re on the latest version of 0.x</strong></p><p>Please make sure you&#x27;re on the latest 0.x version first. Here is a list of all the latest versions:</p><ul><li><code>grunt-stryker@0.13.17</code></li><li><code>stryker-api@0.24.1</code></li><li><code>stryker-babel-transpiler@0.10.1</code></li><li><code>stryker-html-reporter@0.18.1</code></li><li><code>stryker-jasmine-runner@0.4.1</code></li><li><code>stryker-jasmine@0.12.1</code></li><li><code>stryker-javascript-mutator@0.14.1</code></li><li><code>stryker-jest-runner@1.4.1</code></li><li><code>stryker-karma-runner@0.24.1</code></li><li><code>stryker-mocha-framework@0.15.1</code></li><li><code>stryker-mocha-runner@0.17.1</code></li><li><code>@stryker-mutator/test-helpers@0.1.1</code></li><li><code>stryker-typescript@0.18.1</code></li><li><code>stryker-vue-mutator@0.4.1</code></li><li><code>stryker-wct-runner@0.3.1</code></li><li><code>stryker-webpack-transpiler@0.9.1</code></li><li><code>stryker@0.35.1</code></li></ul><p>First update them in your package.json file, next use <code>npm install</code> (or <code>yarn install</code>) to install the versions.</p></li><li><p><strong>Fix all deprecation warnings</strong></p><p>If you&#x27;re on the latest 0.x release, run <code>npx stryker run</code> and fix any deprecation warnings that are logged.
If Stryker runs without deprecation warnings, you&#x27;re ready to upgrade</p></li><li><p><strong>Update your global stryker-cli</strong></p><p>If you&#x27;ve installed the <code>stryker-cli</code>, please update that one as well: <code>npm i -g stryker-cli</code></p></li><li><p><strong>Upgrade your dependencies</strong></p><p>Update your package.json file.</p><ul><li><code>stryker</code> ‚û° <code>@stryker-mutator/core</code></li><li><code>stryker-api</code> ‚û° <em>none, this can be removed</em></li><li><code>stryker-babel-transpiler</code> ‚û° <code>@stryker-mutator/babel-transpiler</code></li><li><code>grunt-stryker</code> ‚û° <code>@stryker-mutator/grunt-stryker</code></li><li><code>stryker-html-reporter</code> ‚û° <code>@stryker-mutator/html-reporter</code></li><li><code>stryker-jasmine</code> ‚û° <code>@stryker-mutator/jasmine-framework</code></li><li><code>stryker-jasmine-runner</code> ‚û° <code>@stryker-mutator/jasmine-runner</code></li><li><code>stryker-javascript-mutator</code> ‚û° <code>@stryker-mutator/javascript-mutator</code></li><li><code>stryker-jest-runner</code> ‚û° <code>@stryker-mutator/jest-runner</code></li><li><code>stryker-karma-runner</code> ‚û° <code>@stryker-mutator/karma-runner</code></li><li><code>stryker-mocha-framework</code> ‚û° <code>@stryker-mutator/mocha-framework</code></li><li><code>stryker-mocha-runner</code> ‚û° <code>@stryker-mutator/mocha-runner</code></li><li><code>stryker-mutator-specification</code> ‚û° <code>@stryker-mutator/mutator-specification</code></li><li><code>stryker-test-helpers</code> ‚û° <code>@stryker-mutator/test-helpers</code></li><li><code>stryker-typescript</code> ‚û° <code>@stryker-mutator/typescript</code></li><li><code>stryker-util</code> ‚û° <code>@stryker-mutator/util</code></li><li><code>stryker-vue-mutator</code> ‚û° <code>@stryker-mutator/vue-mutator</code></li><li><code>stryker-wct-runner</code> ‚û° <code>@stryker-mutator/wct-runner</code></li><li><code>stryker-webpack-transpiler</code> ‚û° <code>@stryker-mutator/webpack-transpiler</code></li></ul><p>The versioning of these dependencies start at 1.0.0, so feel free to use <code>^1.0.0</code> to specify the version.</p><p>After updating your package.json, you&#x27;ll need to run <code>npm install</code> (or <code>yarn install</code>) once more.</p></li><li><p><strong>Take it for a spin</strong></p><p>Stryker should now work as expected. Try it out with: <code>npx stryker run</code>.</p></li></ol><h2>Release cycle</h2><p>From now on we&#x27;ll adhere to strict <a href="https://semver.org/spec/v2.0.0.html">semantic versioning</a>, or semver for short.
This means that it&#x27;s easy to distinguish between bug fixes, new features or breaking changes just
by looking at the version number.</p><p>Futhermore, we&#x27;ve decided to use <em>fixed versioning</em> for our packages, meaning that all <code>@stryker-mutator/*</code> packages
will <em>have the same version number</em>. For example, if your local <code>@stryker-mutator/core</code> version is <code>1.0.0</code>, your
<code>@stryker-mutator/html-reporter</code> should also be at that exact version. This makes maintaining your Stryker dependencies a breeze.</p><p>This is comparable to how Angular or React do their versioning.</p><h2>Release schedule</h2><p>We&#x27;ll be releasing about as often as we were doing. The key difference is that we&#x27;ll be extra focused on
semver. Since we will be dropping support for old NodeJS versions as soon as
<a href="https://github.com/nodejs/Release#release-schedule">it reaches end-of-life</a>,
expect <em>at least</em> one major release a year, (however, we might do more major releases).
So you can expect a v2 release around April 30th, since we&#x27;ll be dropping Node.JS 6 support at that time
(the best birthday gift for me each year üéÅ)</p><p>We&#x27;ll also keep a healthy deprecation policy, making sure that deprecated features remain in tact for at least one major release.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stryker4s 0.1.0 released]]></title>
        <id>stryker4s-0-1-0-released</id>
        <link href="https://stryker-mutator.io/blog/stryker4s-0-1-0-released"/>
        <updated>2018-12-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This is the first official release of Stryker4s! Bringing easy mutation testing to Scala sbt projects. And it comes with some great features.]]></summary>
        <content type="html"><![CDATA[<p>This is the first official release of Stryker4s! Bringing easy mutation testing to Scala sbt projects. And it comes with some great features.</p><p>It&#x27;s taken a little longer than we maybe would&#x27;ve liked, but we are very proud of this first release. In this blog post we&#x27;ll tell you about why running with the sbt plugin is a big improvement, and some of the features you can use today for Stryker4s. Although it&#x27;s still possible to use the command-runner for non-sbt projects, we decided a sbt plugin was an important for the first release.</p><h2>Sbt plugin</h2><p>The biggest thing in our first release is the addition of a plugin for sbt. With this plugin, adding Stryker4s is as easy as adding the following line to your <code>plugins.sbt</code> file:</p><pre><code class="language-scala">addSbtPlugin(&quot;io.stryker-mutator&quot; % &quot;sbt-stryker4s&quot; % &quot;0.1.0&quot;)
</code></pre><p>Then just run <code>sbt stryker</code> and you are good to go!</p><p>Not only does this plugin make it a lot easier to add Stryker4s to your project, it also dramatically improves the speed compared to the old command-runner. The reason for this is that the command-runner would simply run the command <code>sbt test</code> for each mutant. This meant that sbt would have to start a new process every single time. If you have ever used sbt before, you probably know this can take a while.</p><p>With the new plugin we can hook into the sbt process and keep it alive. This means sbt only has to start once, and all we have to do is tell sbt to run tests for all the mutants we found. If you&#x27;ve used Stryker for JavaScript before, this may sound familiar. Adding to it, we don&#x27;t even have to compile between mutant runs, which also gives a speed boost. You can read more about that in our <a href="/blog/2018-10-6/mutation-switching">last blog post about mutation switching</a>.</p><p>Big thanks to <a href="https://github.com/scelestino">Scelestino</a> and <a href="https://github.com/Wmaarts">Wmaarts</a> for the help on the plugin.</p><h2>Other features</h2><p>Here are some other things we recently did to improve your mutation testing experience:</p><ul><li>We already support the new categories of mutators that are now <a href="https://github.com/stryker-mutator/stryker4s/pull/115">standardized across Stryker versions</a>.</li><li><a href="https://github.com/stryker-mutator/stryker-handbook/blob/master/mutator-types.md#stryker4s">Scala-specific function mutators</a></li><li><a href="https://github.com/stryker-mutator/stryker4s/blob/master/docs/CONFIGURATION.md#excluded-mutations">Excluding mutations</a> you might not want to test</li><li><a href="https://github.com/stryker-mutator/stryker4s/blob/master/docs/CONFIGURATION.md#excluded-mutations">Setting a minimum mutation score</a> threshold for your build.</li></ul><h2>What&#x27;s next</h2><p>We have a lot planned for the future of Stryker4s. We&#x27;ll keep looking at ways to optimize the performance, and add new features. As well as sorting out some smaller bugs with the current plugin, such as providing proper support for multi-module projects (<a href="https://github.com/stryker-mutator/stryker4s#multi-module-projects">although we have a workaround</a>). We also want to provide a Maven plugin to give Maven users the same benefits and ease of use. Some other things on the roadmap are the new cross-Stryker HTML dashboard, new mutators and focusing on providing a stable working plugin for many different types of projects.</p><p>So, whether you might have a quiet week at work, or want to get away from the family during Christmas dinner, why not try adding mutation testing to your Scala projects? Let us know how it goes üéÑ!</p>]]></content>
        <author>
            <name>Hugo van Rijswijk</name>
            <uri>https://github.com/hugo-vrijswijk</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Announcing Stryker 0.34]]></title>
        <id>announcing-stryker-0-34</id>
        <link href="https://stryker-mutator.io/blog/announcing-stryker-0-34"/>
        <updated>2018-12-24T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Stryker 0.34 is here. This new version comes with features to help you get started. It's never been this easy to mutation test your JS project!]]></summary>
        <content type="html"><![CDATA[<p>Stryker 0.34 is here. This new version comes with features to help you get started. It&#x27;s never been this easy to mutation test your JS project!</p><p>Install Stryker via the command line:</p><pre><code>npm i stryker stryker-api --save-dev
</code></pre><p>Or run <code>stryker init</code> in the root of your project:</p><pre><code>npx stryker init
</code></pre><p>Some features we want to talk about:</p><ul><li><a href="#command-test-runner">Command test runner</a></li><li><a href="#zero-configuration">Zero configuration</a></li><li><a href="#init-presets">Init presets</a></li><li><a href="#web-component-tester-test-runner-plugin">Web component tester test runner plugin</a></li></ul><h2>Command test runner</h2><p>Stryker always was and always will be test runner agnostic. It doesn&#x27;t care which test runner you use.
However, it always required you to install a test runner plugin.
Are you using Jest? Install the &#x27;stryker-jest-runner&#x27;. Want to use mocha? Then the &#x27;stryker-mocha-runner&#x27; is just what you need.
This works great if the test runner of choice is supported, but what do you do when your test runner isn&#x27;t supported?
Like <a href="https://github.com/stryker-mutator/stryker-js/issues/243">Ava.js</a> or <a href="https://github.com/stryker-mutator/stryker-js/issues/325">node-tap</a>
or <a href="https://github.com/stryker-mutator/stryker-js/issues/430">Intern</a> or
maybe you have a custom <code>npm test</code> command. This is why we&#x27;ve added the <code>&#x27;command&#x27;</code> test runner.</p><p>Configure it in your stryker configuration:</p><pre><code class="language-js">// stryker.conf.js
{
    testRunner: &#x27;command&#x27;,
    // Or leave out testRunner, &#x27;command&#x27; is the default test runner
    commandRunner: {
        command: &#x27;npm run mocha&#x27; // optionally choose a different command to run
    }
}
</code></pre><p>Stryker ships with the command test runner, so it doesn&#x27;t need additional plugins. The command test runner will simply run your <code>npm test</code> script.
If the exit code is <code>0</code>, the tests succeeded. If not, they failed.</p><p>Stryker is limited in the ways it can optimize for performance. For example, it starts a fresh node process for each test run.
So if your test runner is supported via a test runner plugin, that would still be the way to go.</p><p>The command test runner runs <code>npm test</code> by default. You can configure a different command with the <code>commandRunner</code> configuration key.</p><p>Special thanks to <a href="https://twitter.com/DiegoRBaquero">Diego R.B.</a> for inspiring us to implement this.</p><h2>Zero configuration</h2><p>Stryker now chooses sensible defaults for all settings. Meaning that you can now run Stryker without any configuration.
It will look for <!-- -->*<!-- -->.js files to mutate in your <code>src</code> and <code>lib</code> directories (excluding obvious test files, like app.spec.js).
Coverage analysis will be turned off and the <a href="#command-test-runner">command test runner</a> is used.</p><pre><code>npm install --save-dev stryker stryker-api
npx stryker run
</code></pre><p><strong>Note:</strong> The default mutator Stryker uses will still be the deprecated <code>es5</code> mutator (comes with Stryker). In time, we&#x27;ll be migrating this to
use the <code>&#x27;javascript&#x27;</code> mutator (supporting ESNext).</p><p>With these defaults in place, it is now also easy to run Stryker without a configuration file if you want just one or two config options
to change. For example:</p><pre><code>npx stryker run --testRunner mocha --mutator javascript
</code></pre><p>Again, special thanks to <a href="https://twitter.com/DiegoRBaquero">Diego R.B.</a> for inspiring us to implement this.</p><p>With this feature in place, Stryker is now effectively a drop in replacement for <a href="https://github.com/TheSoftwareDesignLab/mutode">mutode</a>.</p><h2>Init presets</h2><p>With <code>stryker init</code> (either using the <a href="https://github.com/stryker-mutator/stryker-cli">stryker-cli</a>, or using <code>npx stryker init</code>)
you can initialize Stryker in your repository. It asks questions via a questionnaire, like &quot;Which test runner do you want to use?&quot; and
&quot;Which test framework do you want to use?&quot;. Sometimes you might not know the answer to those questions. It also might take a lot more
configuration to get you started. This is why we added a <a href="https://github.com/stryker-mutator/stryker-handbook/tree/master/stryker/guides">guides section to the stryker handbook</a>.
We&#x27;ve now integrated those into the <code>stryker init</code> command.</p><pre><code>$ stryker init
? Are you using one of these frameworks? Then select a preset configuration. (Use arrow keys)
&gt; angular-cli
react
vueJs
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
None/other
</code></pre><p>Choosing for a preset immediately gets you started! It creates the configuration file and installs the correct plugins.
Choosing <code>None/other</code> here will still take you to the normal questionnaire.</p><p>Special thanks to <a href="https://github.com/Wmaarts">wmaarts</a> for adding this feature.</p><h2>Web component tester plugin</h2><p>With this release of Stryker, we&#x27;ve also released version 0.1.0 of the stryker-wct-runner. Install it with:</p><pre><code>$ npm install --save-dev stryker-wct-runner
</code></pre><p>Configure it with:</p><pre><code class="language-js">{
  testRunner: &#x27;wct&#x27;;
}
</code></pre><p>With this plugin, we now support <a href="https://www.polymer-project.org/">Polymer</a> cli projects.
The <a href="https://www.npmjs.com/package/web-component-tester">web-component-tester</a> runs your tests in an actual browser.
However, it doesn&#x27;t support any of the coverage analysis performance features for now. If you want those to be supported,
please open an issue. You&#x27;re also welcome to take a look at the <a href="https://github.com/Polymer/tools/issues/created_by/nicojs">issues we&#x27;ve opened at Polymer side</a>.
Any help there is really appreciated.</p><h2>What&#x27;s next?</h2><p>We&#x27;re still focussing on getting v1 out of the door. We&#x27;re reasonably certain it will happen in Q1 of next year.
V1 will mostly be removing deprecated features. We&#x27;ll also introduce a more predictable release schedule with
strict <a href="https://semver.org/spec/v2.0.0.html">Semantic Versioning</a> policies. Stay tuned.</p><p>Input on these new features or the v1 preparations are welcome!</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mutation switching in Stryker4s]]></title>
        <id>mutation-switching</id>
        <link href="https://stryker-mutator.io/blog/mutation-switching"/>
        <updated>2018-10-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Learn how Stryker4s uses mutation switching to improve performance.]]></summary>
        <content type="html"><![CDATA[<p>Learn how Stryker4s uses mutation switching to improve performance.</p><p>We are very happy with Stryker&#x27;s new friends! One of those new friends is Stryker4s(cala).
Scala developers can now use mutation testing to improve their tests!
Creating a mutation testing framework for Scala comes with many challenges.
One of those challenges is the Scala compiler itself.
We all know it&#x27;s not the <a href="https://scala-ci.typesafe.com/grafana/dashboard/db/scala-benchmark?from=1429139130109&amp;to=1492531027936h&amp;orgId=1&amp;var-branch=2.11.x&amp;var-branch=2.12.x&amp;var-branch=2.13.x&amp;var-source=scala&amp;var-bench=HotScalacBenchmark.compile&amp;var-host=scalabench@scalabench@">fastest in its kind</a>.
One of the main goals of Stryker is to be fast. This means we need to come up with an intelligent way to introduce the mutants into the source code.</p><h2>Attempt one: Compiling each mutation</h2><p>One way of introducing mutants to a codebase is by mutating one statement, compile the code, run tests, gather the results and repeat.
This seems like a logical choice because it mimics the way a developer would go about it.</p><p>Let&#x27;s look at an example.</p><pre><code class="language-scala">class Numbers {
    def greaterThan(a: Int, b: Int): Boolean = {
        a &gt; b
        // Mutant 1: a &gt;= b
        // Mutant 2: a &lt; b
        // Mutant 3: a == b
    }
}
</code></pre><p>As you can see, there are three possible mutants:</p><ol><li>Change <code>&gt;</code> to <code>&gt;=</code></li><li>Change <code>&gt;</code> to <code>&lt;</code></li><li>Change <code>&gt;</code> to <code>==</code></li></ol><p>If we apply the mutation one by one, we would need to compile the code base three times.
If we assume the compile time of this program is 10 seconds, we already have 30 seconds of compile time for one full mutation run.
This would quickly get out of hand when the codebase is bigger and generates more mutants.</p><h2>Attempt two: Mutating bytecode</h2><p>As you might know, Scala gets compiled to Java bytecode. This gives us an alternative way to introduce mutations in a codebase.
We would be able to mutate the bytecode directly, eliminating the need for recompiling.</p><p>The main challenge with this approach is that <a href="https://docs.scala-lang.org/overviews/core/binary-compatibility-of-scala-releases.html">Scala doesn&#x27;t guarantee the bytecode output for each version of the compiler</a> (or even JDK version).
Even the jump from Scala 2.12 to 2.13 produces different bytecode. This would make manipulating bytecode complicated, unpredictable and hard to maintain.</p><p>Furthermore, if you mutate the bytecode, it can be difficult to reproduce the exact Scala code that you changed.
Details, like the exact location, are not represented in bytecode.
Scala makes this extra challenging, as 1 <code>.scala</code> file can easily result in 100 <code>.class</code> files in bytecode.</p><p>For performance reasons, mutating bytecode might sound like a fast solution, but you would still need to load (or hot reload) the mutated class files
for each mutant.</p><p>There should be a better solution out there, right?</p><h2>Solution: Mutation switching</h2><p>Mutation switching to the rescue! So how is mutation switching both <em>faster</em> and <em>more reliable</em> than compiling each mutation or mutating bytecode?
The steps are quite similar to &quot;Compiling each mutant&quot;, but with some big differences:</p><ol><li>All mutants are identified for the whole codebase.</li><li>All mutants are applied to the codebase <strong>at the same time</strong> using a <a href="https://docs.scala-lang.org/tour/pattern-matching.html">Scala Pattern match</a>.</li><li>All mutants are tested one by one, with only <strong>one mutant active at a time</strong>, using an environment variable.</li></ol><p>Step 2 is where the magic happens. Let&#x27;s take a look at the same code example as used previously, right after the mutations are applied.</p><pre><code class="language-scala">class Numbers {
    def greaterThan(a: Int, b: Int): Boolean = {
        sys.env.get(&quot;ACTIVE_MUTATION&quot;) match {
            case Some(&quot;0&quot;) =&gt;
                a &gt;= b
            case Some(&quot;1&quot;) =&gt;
                a &lt; b
            case Some(&quot;2&quot;) =&gt;
                a == b
            case _ =&gt;
                a &gt; b
        }
    }
}
</code></pre><p>All possible mutations are implemented in the pattern match. An identifier is used to turn on/off, or <em>switch</em>, specific mutations.
The default case will be used when none of the mutants are active. Now the code base only needs to be compiled once.
The extra time compilation takes because of its increased size is negligible compared to the overhead of compiling each mutant.
For example, if the compilation time for this code base
would be 15 seconds we will still gain 15 seconds compared to compiling each mutation.</p><p>We gain performance without losing flexibility. It&#x27;s a win-win scenario.</p><h2>Top statements</h2><p>Mutation switching sure is great, but let&#x27;s take a look at a more complex example.</p><pre><code class="language-scala">def isEven(number: Int): Boolean = number % 2 == 0
def isOdd(number: Int): Boolean = !isEven(number)

val numbers: List[Int] = 1 to 100 toList

def filterOddAnd(specialNumber: Int): List[Int] = {
  numbers
    .filter(isOdd)
    .filterNot(_.equals(specialNumber))
}
</code></pre><p>With this code base <code>filter</code> and <code>filterNot</code> could be mutated to there counterparts.
This would give us the following code base if we implement the pattern match at the direct position.</p><pre><code class="language-scala">def isEven(number: Int): Boolean = number % 2 == 0
def isOdd(number: Int): Boolean = !isEven(number)

val numbers: List[Int] = 1 to 100 toList

def filterOddAnd(specialNumber: Int): List[Int] = {
  numbers.(sys.env.get(&quot;ACTIVE_MUTATION&quot;) match {
    case Some(&quot;0&quot;) =&gt; .filter(isOdd)
    case _         =&gt; .filterNot(isOdd)
  }).
  (sys.env.get(&quot;ACTIVE_MUTATION&quot;) match {
    case Some(&quot;1&quot;) =&gt;  .filterNot(_.equals(specialNumber))
    case _         =&gt;  .filter(_.equals(specialNumber))
  })
}
</code></pre><p>Because we wrapped the functions right on the spot we produced code that doesn&#x27;t even compile!
To make the code compile we need to take a closer look at the abstract syntax tree.
We are searching for the parent statement in this abstract syntax tree, which is <code>numbers</code> in our case.
If we implement mutation switching using the parent statement, we can generate the following code.</p><pre><code class="language-Scala">def isEven(number: Int): Boolean = number % 2 == 0
def isOdd(number: Int): Boolean = !isEven(number)

val numbers: List[Int] = 1 to 100 toList

def filterOddAnd(specialNumber: Int): List[Int] = {
  sys.env.get(&quot;ACTIVE_MUTATION&quot;) match {
    case Some(&quot;0&quot;) =&gt; numbers.filterNot(isOdd).filter(_.equals(specialNumber))
    case Some(&quot;1&quot;) =&gt; numbers.filter(isOdd).filter(_.equals(specialNumber))
    case _         =&gt; numbers.filter(isOdd).filterNot(_.equals(specialNumber))
  }
}
</code></pre><p>This enables us to get clean, readable pattern matches and avoid compilation errors.</p><h2>What&#x27;s next?</h2><p>With mutation switching in place, the road is clear for even bigger performance improvements. Right now, we&#x27;re not
keeping the testing process alive. We simply run <code>sbt test</code> with the correct mutant switched on.
Keeping the test process alive and rerunning the tests after switching mutants is where we can really put the pedal to the metal!</p><p>Interested to help? We&#x27;re very much looking for contributions! Take a look at our <a href="https://github.com/stryker-mutator/stryker4s/issues">issue tracker</a>
or contact us on <a href="https://join.slack.com/t/stryker-mutator/shared_invite/enQtOTUyMTYyNTg1NDQ0LTU4ODNmZDlmN2I3MmEyMTVhYjZlYmJkOThlNTY3NTM1M2QxYmM5YTM3ODQxYmJjY2YyYzllM2RkMmM1NjNjZjM">Slack</a>.</p><h2>Conclusion</h2><p>With the combination of mutation switching and traversing to the parent statements Stryker4s is able to apply mutations to the codebase
in a clean and understandable fashion and keep the chances of compilation errors to a minimum.
We hope this blog gave some insight on mutation switching works and how Stryker4s uses this to its advantage. Happy mutating!</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Introducing Stryker.NET and Stryker4s]]></title>
        <id>csharp-and-scala-support</id>
        <link href="https://stryker-mutator.io/blog/csharp-and-scala-support"/>
        <updated>2018-09-27T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We're excited to announce that we're doubling the number of supported languages for Stryker. We already had support for JavaScript and Typescript, and now both C# and Scala are supported as preview versions. Try them out and let us know what you think.]]></summary>
        <content type="html"><![CDATA[<p>We&#x27;re excited to announce that we&#x27;re doubling the number of supported languages for Stryker. We already had support for JavaScript and Typescript, and now both C# and Scala are supported as preview versions. Try them out and let us know what you think.</p><h2>New platforms</h2><p>As you might know, both C# and Scala run on entirely different platforms compared to Stryker (which runs on NodeJS). This is the main reason we decided to implement them as
separate frameworks. <a href="/stryker-net">Stryker.NET</a> is written in C# and runs as a .NET Core application, while <a href="/stryker4s">Stryker4s</a> is written in Scala and runs on the JVM (Java Virtual Machine).
As of now, a version of Stryker.NET can be found on nuget.org, the package manager for the .NET platform. In due time, Stryker4s can be found on Maven Central.</p><p>Stryker.NET is the result of the internship of <a href="https://github.com/richardwerkman">Richard</a>.<br/>
<!-- -->Stryker4s is the result of the internship of <a href="https://github.com/hugo-vrijswijk">Hugo</a>.</p><p>Thanks to them both for their hard work and continued support.</p><h2>Getting started</h2><p>As you might have noticed, we&#x27;ve redesigned <a href="/">our website</a>. It is focussed to help you get started on the platform of choice.</p><ul><li><a href="/stryker-net/quickstart">Get started with Stryker.NET</a> (preview)</li><li><a href="/stryker4s/quickstart">Get started with Stryker4s</a> (preview)</li><li><a href="/stryker/quickstart">Get started with Stryker</a> (for JavaScript / TypeScript)</li></ul><h2>One design mentality</h2><p>Although all 3 versions of Stryker are implemented on different platforms, the design goals are the same. It should be <em>easy to use</em> and
<em>fast to run</em>. Without compromises.</p><p>For Stryker JavaScript we&#x27;re mutating <em>source code</em> (as explained in our
<a href="/blog/2017-07-14/road-to-stryker-1-0">road to Stryker 1.0</a> blog post), instead of transpiled/minified JavaScript code.
The main advantage is that it makes sure we only mutate <em>your actual code</em>, instead of 3rd party library or minified code.</p><p>We wanted to offer the same quality to the .NET and Scala counterparts, but they have one additional problem: compiling code takes a long time.
It would dramatically reduce the performance of the frameworks. This is why we chose to implement a new mutation testing technique we call <em>Mutation Switching</em>.
With this technique, we compile only once. This results in a drastic performance gain, without compromising the quality of the mutations.
It really deserves it&#x27;s own blog post, so more on that later.</p><h2>Collaboration</h2><p>Though the 3 frameworks have their own code base, there are actually a lot of points on which we&#x27;re planning to collaborate.</p><ul><li><strong>One vocabulary</strong>\
Terms like <em>mutant</em>, <em>survived</em> and <em>mutator</em> will mean the same across platforms. We will even share the names
for the mutators, see <a href="https://github.com/stryker-mutator/stryker-handbook/blob/master/mutator-types.md#supported-mutators">the supported mutators in our handbook</a>
for a comprehensive list of supported mutators.</li><li><strong>One website</strong>\
We&#x27;ll keep things together with <a href="/">one website</a>. This will help visibility for all platforms and keep things simple for our users.</li><li><strong>One html reporter</strong>\
We&#x27;re redesigning our html report as <a href="https://www.webcomponents.org/">HTML 5 web components</a>. It really is it&#x27;s own thing and might even be used for other mutation testing frameworks out there.
Interested to help? Please let us know! <a href="https://github.com/stryker-mutator/mutation-testing-elements">Github repository here</a>.</li><li><strong>One dashboard</strong>\
We&#x27;re planning on supporting our <a href="https://dashboard.stryker-mutator.io">mutation testing dashboard</a> for all 3 implementations.</li></ul><h2>What about good old Stryker?</h2><p>You might wonder what this all means for Stryker (for JavaScript and friends). Well, not much. The core developers are still here, focussed as ever.
We&#x27;re still focused on getting the 1.0 release out there for you.
We had to invest some time in the overhead of setting this all up, but it will result in better and more complete frameworks in the end.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Use git to select files]]></title>
        <id>use-git-to-select-files</id>
        <link href="https://stryker-mutator.io/blog/use-git-to-select-files"/>
        <updated>2018-04-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The 0.21 release of Stryker simplifies configuration by using your git database.]]></summary>
        <content type="html"><![CDATA[<p>The 0.21 release of Stryker simplifies configuration by using your git database.</p><p>For a change log per package:</p><ul><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker/CHANGELOG.md">stryker changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-api/CHANGELOG.md">stryker-api changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-mocha-runner/CHANGELOG.md">stryker-mocha-runner changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-karma-runner/CHANGELOG.md">stryker-karma-runner changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-typescript/CHANGELOG.md">stryker-typescript changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-webpack-transpiler/CHANGELOG.md">stryker-webpack-transpiler changelog</a></li></ul><h2>Sandboxes</h2><p>Stryker only works on copies of your source code. A copy is called a <em>sandbox</em>. It creates as much of them as you want parallel test runners.
You don&#x27;t want a big sandbox. Just imagine what would happen if all your node_modules end up in there! That&#x27;s why Stryker allows you to configure
the files to load into it.</p><p>One of the most common issues in <a href="https://github.com/stryker-mutator/stryker-js/issues">our issue tracker</a> has to do with
the way you needed to configure it using the <code>files</code> configuration. It was very confusing. The fact that stryker-karma-runner (pre 0.13) and stryker-typescript (pre 0.10)
modified your files array (without you knowing it) only added to the complexity.
Just <a href="https://github.com/nicojs/angular-stryker-example/blob/72d85e19657247a77faa8e12587d3d301147b2bd/stryker.conf.js#L6">a small look at the angular example file</a>
will leave you scratching your head.</p><p>Further more, you had properties like <code>included</code>, <code>transpiled</code> and <code>mutated</code>. It was kind of a mess really.</p><h2>Remove your <code>files</code> configuration</h2><p>No longer! From release 0.21 of Stryker, the files array is <em>optional</em>. Please remove it. Everything should work as expected.
Stryker will fallback to a sane default: your git database. It does this by executing the following command:
<code>git ls-files --others --exclude-standard --cached</code>. The result should be exactly what you want in your sandbox
(given you&#x27;re using <code>.gitignore</code> files like a boss). If you want to deviate from this for whatever reason,
you can still use the <code>files</code> property with an array of strings.</p><p>Stryker also stopped keeping track of <code>included</code>, <code>transpiled</code> and <code>mutated</code> properties. For <code>mutate</code> please use the
designated <a href="https://github.com/stryker-mutator/stryker-js/tree/master/packages/stryker#source-code-files-to-mutate"><code>mutate</code> top level stryker property</a>.</p><h2>Breaking change!</h2><p>Unfortunately we couldn&#x27;t create this feature without some breaking changes. The biggest one is that we&#x27;ve had to remove the old
<code>InputFileDescriptor</code> object way of defining your input file.</p><p>This:</p><pre><code class="language-js">// DEPRECATED
files: [{ pattern: &#x27;pattern&#x27;, included: true, mutated: true, transpiled: true }];
</code></pre><p>Is deprecated. If you are using it we strongly suggest to try to remove <code>files</code> entirely.</p><p>We&#x27;ve had to update the API to test runner plugins and transpiler plugins as well. Before, Stryker was keeping track of which file
needed to be included in the test runner or transpiled by the transpiler. This is
no longer the case. To see what this means for you, please consult the readme of the plugins you are using:</p><ul><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-mocha-runner/README.md">stryker-mocha-runner readme</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-karma-runner/README.md">stryker-karma-runner readme</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-typescript/README.md">stryker-typescript readme</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-webpack-transpiler/README.md">stryker-webpack-transpiler readme</a></li></ul><h2>What&#x27;s next?</h2><p>With this major refactoring out of the way we will hone in to our next target: an actual v1 release.
We&#x27;ve opened up <a href="https://github.com/stryker-mutator/stryker-js/issues/654">issue 654</a> to keep track of our
progress on this front. Want to help? Or curious about our plans? Please get in touch.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Get your mutation score badge now!]]></title>
        <id>get-your-mutation-score-badge-now</id>
        <link href="https://stryker-mutator.io/blog/get-your-mutation-score-badge-now"/>
        <updated>2018-02-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We're launching our Stryker Dashboard today.]]></summary>
        <content type="html"><![CDATA[<p>We&#x27;re launching our <a href="https://dashboard.stryker-mutator.io">Stryker Dashboard</a> today.
This will be the home of your test quality in the future.
The first feature? A mutation score badge!</p><p><img src="https://img.shields.io/badge/mutation%20score-82.3-green.svg" alt="badge green"/>
<img src="https://img.shields.io/badge/mutation%20score-72.3-orange.svg" alt="badge orange"/>
<img src="https://img.shields.io/badge/mutation%20score-59.6-red.svg" alt="badge red"/></p><h2>Tell me how!</h2><p>Take these steps to enable the mutation score badge on your repository.</p><ul><li><strong>Step 1</strong>: Make sure you can run stryker during a <a href="https://travis-ci.org">travis</a> build (we only support travis at the moment).</li><li><strong>Step 2</strong>: Go to <a href="https://dashboard.stryker-mutator.io">https://dashboard.stryker-mutator.io</a> and sign with your github account.</li><li><strong>Step 3</strong>: Flip the switch next to your repository:<svg _ngcontent-c6="" height="50" width="250" xmlns="http://www.w3.org/2000/svg"><g _ngcontent-c6=""><title _ngcontent-c6="">background</title><rect _ngcontent-c6="" x="0" y="0" width="250" height="50" ry="20" rx="20" fill="#fff" r="50" stroke="#E7E8E6" stroke-width="1.5"></rect></g><g _ngcontent-c6=""><title _ngcontent-c6="">Switch</title><text _ngcontent-c6="" text-anchor="start" x="10" y="30">username/reponame</text><rect _ngcontent-c6="" fill="#E77964" height="20" rx="10" ry="50" width="45" x="180" y="15"></rect><circle _ngcontent-c6="" cx="215" cy="25" fill="#b74934" r="13"></circle></g></svg></li><li><strong>Step 4</strong>: Configure your api key in your project. Please make sure you encrypt this variable using the <a href="https://docs.travis-ci.com/user/environment-variables/#Encrypting-environment-variables">encrypted environment variables</a>.
For example:<br/><code>$ travis encrypt STRYKER_DASHBOARD_API_KEY=89b99910-04d8-4ffb-9a91-23d709c828b4 --add</code></li><li><strong>Step 5</strong>: Configure the dashboard reporter in your stryker.conf.js file (you will need stryker version 0.19.1 or higher):<br/><code>reporter: [ /*...*/ &#x27;dashboard&#x27; ]</code></li><li><strong>Step 6</strong>: Force a travis build<br/><code>$ git push origin master</code></li></ul><p>Your badge will be available at: <code>https://badge.stryker-mutator.io/github.com/{username}/{repository_name}/{branch}</code>.
(don&#x27;t forget to add it to your readme file)</p><p>Real life examples of the mutation score badge:</p><ul><li><a href="https://github.com/stryker-mutator/stryker-jest-runner#readme">stryker-mutator/stryker-jest-runner</a> <img src="https://badge.stryker-mutator.io/github.com/stryker-mutator/stryker-jest-runner/master" alt="badge"/></li><li><a href="https://github.com/nicojs/node-install-local#readme">nicojs/node-install-local</a> <img src="https://badge.stryker-mutator.io/github.com/nicojs/node-install-local/master" alt="badge"/></li><li><a href="https://github.com/nicojs/node-sdedit#readme">nicojs/node-sdedit</a> <img src="https://badge.stryker-mutator.io/github.com/nicojs/node-sdedit/master" alt="badge"/></li></ul><h2>What&#x27;s next?</h2><p>A mutation score badge sure is nice, but what does the future bring?</p><p>First we want to support monorepo style projects (stryker itself is a mono-repo). Every package in your monorepo will have its own badge.
We also want to support a cumulative badge for in your main readme file.</p><p>We would also like to support more build servers and use cases. Are you missing a feature?
Please let us know by opening <a href="https://github.com/stryker-mutator/stryker-dashboard/issues/new">an issue</a>.</p><p>But the dashboard is more than just badges. We truly want to make this the home of your test quality.
You can think of features like:</p><ul><li>Showing your html mutation report.</li><li>Keep your history and show trend lines.</li><li>Informing you how a pull request changes your mutation score.</li><li>Support mutation testing frameworks for other languages.</li></ul><p>We are curious to know what you think.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Webpack support is here]]></title>
        <id>webpack-support</id>
        <link href="https://stryker-mutator.io/blog/webpack-support"/>
        <updated>2018-01-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Stryker now supports bundling your code using webpack before running your tests.]]></summary>
        <content type="html"><![CDATA[<p>Stryker now supports bundling your code using webpack before running your tests.
The installation/upgrade scenario&#x27;s in this blog post can be circumvented by using the <a href="https://stryker-mutator.github.io/quickstart.html">Quickstart</a> if you don&#x27;t already use Stryker in your project.</p><p><img src="/images/blogs/love-webpack.png"/></p><h2>A bundle for each mutant?</h2><p>Ok. Stryker can mutate your code. We support both JavaScript and TypeScript.
However, the tests of many web projects first need to be bundled before they can be loaded in the browser for testing.
Stryker <a href="./2017-07-14-road-to-stryker-1-0.md#open-heart-surgery">mutates your source files</a>,
rather than the resulting JS bundle. This means that you still need to tell Stryker how your bundle is created.</p><h2>Webpack transpiler</h2><p>Let&#x27;s say we&#x27;re using <a href="https://webpack.js.org">Webpack</a> to create that bundle. Well sir, let me bring you up-to-speed. We have just
<a href="https://www.npmjs.com/package/stryker-webpack-transpiler">released the stryker-webpack-transpiler</a> and with it, Stryker uses <em>your webpack configuration</em>
to create the testing bundle.</p><p>To use the new Webpack transpiler, start by installing the package:</p><pre><code>npm install --save-dev stryker-webpack-transpiler
</code></pre><p>And configure it in your stryker.conf.js:</p><pre><code class="language-js">transpilers: [&#x27;webpack&#x27;],
webpack: {
    configFile: &#x27;webpack.config.js&#x27;, // Is your webpack config file somewhere else? Please specify it here.
    silent: true // This removes the &quot;ProgressPlugin&quot; from your config before feeding it through Stryker
},
</code></pre><p>For more info, please see the <a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-webpack-transpiler/CHANGELOG.md">stryker-webpack-transpiler changelog</a>
or take a look at the <a href="https://github.com/stryker-mutator/stryker-js/tree/master/packages/stryker-webpack-transpiler#readme">readme</a></p><p>Enjoy!</p><h2>Can I use...</h2><h3>Angular?</h3><p>With this new support for webpack, we now start to support <a href="https://angular.io">Angular</a> projects!
However, you still need to provide a webpack configuration to Stryker. If you&#x27;re using the <a href="https://npmjs.com/package/@angular/cli">angular cli</a>
you probably don&#x27;t have a <code>webpack.config.js</code> file lying around. In that case, head on over to <a href="https://github.com/nicojs/angular-stryker-example">nicojs/angular-stryker-example</a>
and take a look. We have tested it on small sized projects (&lt; 100 tests). We would love your feedback if you&#x27;re using it on larger projects.</p><h3>React?</h3><p>Unfortunately, this release does not mean that we now support mutation testing on react projects, as they don&#x27;t use webpack
for testing. Instead, you&#x27;re probably using <a href="https://facebook.github.io/jest">Jest</a> which is responsible for loading your tests
in a nodejs environment (using <a href="https://github.com/tmpvar/jsdom">JSDom</a>).</p><p>However, we are working on first class support for any project using Jest, so you won&#x27;t have to wait long.</p><h2>What&#x27;s next?</h2><p>Webpack support is awesome, but performance does take a big hit if we need to bundle each mutant.
Having the coverage analysis can help a lot with that. As of yet, we don&#x27;t support coverage analysis
when using a transpiler. However, <a href="https://github.com/stryker-mutator/stryker-js/pull/559">PR 559</a> looks promising
and we&#x27;ll be merging that into master in about a week or so.</p><p>We will also be working on React support with support for the Jest test runner. You can expect that in the next
couple of weeks as well.</p><h2>Special thanks</h2><p>Special thanks go out to <a href="https://github.com/Archcry">@Archcry</a>. He created the webpack plugin during his internship.
Give him some love!</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript coverage analysis support]]></title>
        <id>typescript-coverage-analysis-support</id>
        <link href="https://stryker-mutator.io/blog/typescript-coverage-analysis-support"/>
        <updated>2018-01-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Let's start this new year strong. Stryker 0.18 adds coverage analysis support for transpilers, starting with the TypeScript transpiler.]]></summary>
        <content type="html"><![CDATA[<p>Let&#x27;s start this new year strong. Stryker 0.18 adds coverage analysis support for transpilers, starting with the TypeScript transpiler.</p><p>This article first explains the basics of <a href="https://en.wikipedia.org/wiki/Code_coverage">(code) coverage</a> analysis for mutation testing in general, before focussing on the new feature.</p><p>See the original PR for even more details:</p><ul><li><a href="https://github.com/stryker-mutator/stryker-js/pull/559">feat(coverage analysis): Support transpiled code #559</a></li></ul><h2>Coverage analysis</h2><p>It might not sound particularly sexy, but (code) coverage analysis is an important feature of any mutation testing framework.
Mutation testing takes a long time. The most effective way to save time, is to do less work.</p><p>Take this small piece of JavaScript code:</p><pre><code class="language-javascript">// Source code:
function sum(a, b) {
  return a + b;
}

function product(a, b) {
  return a * b;
}

function difference(a, b) {
  return a - b;
}
</code></pre><pre><code class="language-javascript">// The tests:
describe(&#x27;Math&#x27;, () =&gt; {
  it(&#x27;should give 3 for sum(1, 2)&#x27;, () =&gt; {
    expect(sum(1, 2)).to.eq(3);
  });

  it(&#x27;should give 12 for product(3, 4)&#x27;, () =&gt; {
    expect(product(3, 4)).to.eq(12);
  });
});
</code></pre><h3>Coverage analysis: &#x27;all&#x27;</h3><p>As you can see the <code>sum</code> and <code>product</code> functions are reasonably well tested, but the the <code>difference</code> function isn&#x27;t tested at all.</p><p>For example: what would the result be for the mutant that changes <code>a - b</code> to <code>a + b</code>? It doesn&#x27;t even make sense to test it,
anyone can see it will survive anyway.</p><p>If you set coverage analysis to <code>&#x27;all&#x27;</code> inside your stryker.conf.js file, this is exactly what happens. Stryker will automatically
collect code coverage results during the initial test run phase<!-- -->*<!-- -->. If a mutant mutates code that is not tested,
it will be marked as <em>&#x27;no coverage&#x27;</em> (which translates to <em>survived</em> during the score calculation) without ever testing it.
This can safe minutes on larger code bases.</p><ul><li>Coverage analysis is not supported for Jest yet.</li></ul><h3>Coverage analysis: &#x27;perTest&#x27;</h3><p>Nice! We&#x27;re already saving time by analyzing a simple code coverage result. But if we take a closer look, we see that we can save even more time.</p><p>Take the <code>product</code> function for example: we want to test the mutant that changes <code>a * b</code> to <code>a / b</code>. We see that it is covered by a test, so
we cannot skip the actual testing of this mutant. However, we can save time by only running the one test that covers this mutant.</p><p>If you set coverage analysis to <code>&#x27;perTest&#x27;</code> inside your stryker.conf.js file, this is exactly what happens. Stryker will automatically
collect code coverage results <em>per test</em> during the initial test run phase. Next, it will select only those tests that actually cover
a mutant to run for that mutant (again, not supported for Jest yet). This might seem like a small improvements,
but in big projects with 100s of tests, it quickly adds up to minutes.</p><p>It is important to realize that this does not influence the quality of the resulting report at all. It simply less work to reach the same conclusion.</p><h2>The challenge with transpiled code</h2><p>Now that we have a firm understanding of coverage analysis and why it is important, lets dive into the new stuff.
After all, coverage analysis is nothing new for Stryker, it has been there for a long time.
However, it gets more complicated when you add a transpiler to the (delicious) mutation testing mix.</p><p>Please read <a href="./2017-10-06-typescript-support.md">our blog article on transpiling code</a> if your interested in the details on how transpilers are implemented in Stryker.
For now it is is enough that you understand that Stryker mutates your <em>source</em> code, while running the <em>transpiled</em> code in the test runner.
Any coverage analysis we collect will only tell us about the <em>transpiled</em> covered code, while the mutants only work on your <em>source</em> code.</p><p>Take this small piece of TypeScript code:</p><pre><code class="language-typescript">// TypeScript: before transpiling
class Math {
  static sum(a: number, b: number) {
    return a + b;
  }
}
</code></pre><pre><code class="language-javascript">// JavaScript: after transpiling (target: es5)
var Math = /** @class */ (function () {
  function Math() {}
  Math.sum = function (a, b) {
    return a + b;
  };
  return Math;
})();
</code></pre><p>Even with this small example, you can already see that the location of <code>a + b</code> in source code vs transpiled code is totally different.
We need to translate the location of a mutant to the actual transpiled location somehow.</p><h2>Bridging the gap</h2><p>Luckily, any respectable transpiler can produce <a href="https://www.thecssninja.com/javascript/source-mapping">source maps</a>.
They are used by code editors and browsers to debug source code while executing transpiled/minified/bundled code.
And, as of now, this is what is used by Stryker to calculate the transpiled location.</p><p>So if you select coverage analysis &#x27;all&#x27; or &#x27;perTest&#x27; while transpiling using typescript, the stryker-typescript transpiler
plugin will produce source maps during the initial test run. Stryker will use those source maps to translate the transpiled location
of all mutants.</p><h2>Show me the numbers</h2><p>Unfortunately, we do not have a good performance testing mechanism for Stryker yet (PRs and ideas are welcome!),
but the results for mutation testing on Stryker itself are very promising, shaving off about 6 minutes for single run,
about a 50% performance increase.</p><h2>What&#x27;s next?</h2><p>Next up we&#x27;ll work on getting this performance increase to all supported transpilers.
We&#x27;re also working behind the scenes on a transpiler plugin for webpack. Which you can also expect
within the next couple of weeks.</p><p>In the meantime: have fun with this feature. Are you using it? Please let is know what you think! We&#x27;re always
interested to know what we can improve further.</p><p>Have fun.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stryker adds Babel support]]></title>
        <id>babel-support</id>
        <link href="https://stryker-mutator.io/blog/babel-support"/>
        <updated>2017-12-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[A new Stryker plugin that adds support for Babel projects has just been released!]]></summary>
        <content type="html"><![CDATA[<p>A new Stryker plugin that adds support for Babel projects has just been released!</p><p>The installation/upgrade scenario&#x27;s in this blog post can be circumvented by using the <a href="https://stryker-mutator.github.io/quickstart.html">Quickstart</a> if you don&#x27;t already use Stryker in your project.</p><p><img src="/images/blogs/love-babel.png"/></p><h2>New JavaScript mutator</h2><p>In order to support mutating more recent JavaScript features as well as experimental features, we had to change the way we mutate JavaScript code.
We had already released a separate plugin for mutating TypeScript code, but now we have also released a separate plugin for mutating JavaScript code.
It is called the <a href="https://www.npmjs.com/package/stryker-javascript-mutator">stryker-javascript-mutator</a> and it replaces the current &#x27;ES5&#x27; mutator that has always come with Stryker. With this release, the &#x27;ES5&#x27; has been deprecated and it will be removed in the future.</p><p>If you use Stryker with JavaScript code on your project, we highly recommend upgrading to the new stryker-javascript-mutator.</p><p>You can do so by installing the package:</p><pre><code>npm install --save-dev stryker-javascript-mutator
</code></pre><p>And configuring it in your stryker.conf.js:</p><pre><code class="language-js">mutator: &#x27;javascript&#x27;,
</code></pre><p>If you have a plugins section in your config, please consider removing it or add the new styker-javascript-mutator plugin.</p><h2>Babel transpiler</h2><p>Even if Stryker can mutate JavaScript code in which new features are used, your environment may not be able to run that code.
Many people use Babel to convert their modern JavaScript to a format that will run environments that do not support these features.
We developed a new plugin for Stryker, the <a href="https://www.npmjs.com/package/stryker-babel-transpiler">stryker-babel-transpiler</a>, during a hackathon sponsored by <a href="https://opensource.infosupport.com">Info Support</a>.
This plugin is capable of transpiling code written using Babel to code that runs in your environment. Give Stryker your babel config and we&#x27;ll make it work!</p><p>To use the new Babel transpiler, start by installing the package:</p><pre><code>npm install --save-dev stryker-babel-transpiler
</code></pre><p>And configure it in your stryker.conf.js:</p><pre><code class="language-js">transpilers: [&#x27;babel&#x27;],
babelrcFile: &#x27;.babelrc&#x27;, // Is your .babelrc file somewhere else? Please specify it here.
// If you don&#x27;t have a .babelrc file you can specify the config directly (Not recommended!):
// babelConfig: { &quot;presets&quot;: [&quot;env&quot;],  &quot;plugins&quot;: [&quot;transform-object-rest-spread&quot;] },
</code></pre><p>If you have a plugins section in your config, please consider removing it or add the new stryker-babel-transpiler plugin.</p><h2>Webpack projects</h2><p>With these new features, <strong>we unfortunately do not yet have support for projects using Webpack (such as React)</strong>.
If you need Webpack to bundle your code in order to run your tests please let us know what your setup is! This will help us with the development of Webpack support.</p><p>Please try it out yourself and let us know what your think!</p>]]></content>
        <author>
            <name>Simon de Lang</name>
            <uri>https://github.com/simondel</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[New HTML reporter]]></title>
        <id>new-html-report</id>
        <link href="https://stryker-mutator.io/blog/new-html-report"/>
        <updated>2017-10-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The Stryker HTML Reporter version 0.10 has a lot of new features, but more importantly: a sexy new look.]]></summary>
        <content type="html"><![CDATA[<p>The Stryker HTML Reporter version 0.10 has a lot of new features, but more importantly: a sexy new look.</p><p>For the entire changelog:</p><ul><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-html-reporter/CHANGELOG.md">stryker-html-reporter changelog</a></li></ul><h2>Sexy new look</h2><p>Without further ado:</p><p><img src="/images/blogs/html-report-bootstrap4.png"/></p><p>As you might already suspect, we&#x27;ve upgraded to <a href="http://getbootstrap.com/">bootstrap 4 (beta)</a>.</p><h2>New features</h2><p>This new report has a ton of new features:</p><ul><li><strong>Mutant states</strong>. The file report will now show the exact <a href="http://stryker-mutator.github.io/faq.html#q-what-do-all-these-metrics-mean">state of a mutant</a>.
It&#x27;s also possible to filter out the exact states at the top. It even shows the amount of mutants with that state in parentheses.
This should give you more details as to what happened when testing your application.</li><li><strong>Detailed mutant report</strong>. On the right side (or below on small screens) of a file report, you can now see a detailed table with even more information about the mutants.</li><li><strong>Breadcrumb</strong>. The days of getting lost in your Stryker report belong to the past. Behold: the new breadcrumb in your report!</li></ul><p>Please try it out yourself and let us know what your think!</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript support]]></title>
        <id>typescript-support</id>
        <link href="https://stryker-mutator.io/blog/typescript-support"/>
        <updated>2017-10-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Stryker 0.10 marks the biggest change in Stryker history yet, as we now support running mutation testing on TypeScript code.]]></summary>
        <content type="html"><![CDATA[<p>Stryker 0.10 marks the biggest change in Stryker history yet, as we now support running mutation testing on TypeScript code.</p><p>For the entire changelog per package:</p><ul><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker/CHANGELOG.md">stryker changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-api/CHANGELOG.md">stryker-api changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-html-reporter/CHANGELOG.md">stryker-html-reporter changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-typescript/CHANGELOG.md">stryker-typescript changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-mocha-runner/CHANGELOG.md">stryker-mocha-runner changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-mocha-framework/CHANGELOG.md">stryker-mocha-framework changelog</a></li></ul><h2>Language agnostic</h2><p>Stryker is now language agnostic. This means that you can use Stryker to mutation test <em>any</em> language that
transpiles down to JavaScript (as long as you have the correct plugin for it). TypeScript is the first language that is
fully supported in this way.</p><p>To make this possible we made a number of changes to the Stryker core:</p><ul><li>Changed the Mutator plugin api</li><li>Add a Transpiler plugin api</li></ul><h3>Mutator plugin api</h3><p>With the previous Mutator plugin, it was possible to mutate a single Abstract Syntax Tree (AST) node. It was a neat little feature,
but was never used outside of the core Stryker package. This plugin was also specific to JavaScript.
As Stryker is now language agnostic, we decided to move the Mutator api to a higher level of abstraction.
A Mutator is now responsible for mutating code written in a specific language, instead of a single JS AST node.</p><p>We moved the existing es5 Mutator code into a new Mutator called <code>&#x27;es5&#x27;</code>.
It is at this moment still part of the main Stryker npm module, but we have plans to remove it later on.
We also added a <a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-typescript/src/TypescriptMutator.ts"><code>&#x27;typescript&#x27;</code> mutator</a>
as part of the new stryker-typescript npm module.</p><p>You can find the new <a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-api/src/mutant/Mutator.ts">api definition here</a>.</p><h3>Transpiler plugin api</h3><p>With a transpiler plugin, it possible to transform any source code before Stryker runs your tests.
It is also used to transpile each mutant in the same way. This allows maximum freedom when
mutating source code, without having to worry about the resulting JavaScript code.
A side effect is that it will not work with <a href="https://github.com/stryker-mutator/stryker-js/tree/master/packages/stryker#type-of-coverage-analysis">coverage analysis</a> yet,
meaning that Stryker will force coverage analysis to be <code>&#x27;off&#x27;</code> when a transpiler is used.</p><p>We created the <a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-typescript/src/TypescriptTranspiler.ts"><code>&#x27;typescript&#x27;</code> transpiler</a>
as part of the new <code>stryker-typescript</code> npm module.</p><p>You can find the new <a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-api/src/transpile/Transpiler.ts">api definition here</a></p><h2>The TypeScript mutation testing framework</h2><p><a href="https://github.com/stryker-mutator/stryker-js/pull/376">Original PR</a></p><p>Stryker now supports TypeScript. This means that Stryker is now able to work
directly on your TypeScript code, no need to first transpile it yourself and run Stryker on the transpiled code.
This has the following advantages:</p><ul><li>Far less false-positives,</li><li>Your stryker reports will now show your code, instead of transpiled code.</li></ul><h3>&quot;There&#x27;s a plugin for that&quot;</h3><p>All Stryker plugins to help you with TypeScript are part of a single npm module: <a href="https://www.npmjs.com/package/stryker-typescript">stryker-typescript</a>.
It contains 3 plugins that work together:</p><ol><li><strong>Config Editor</strong>: A plugin that reads your tsconfig.json file and makes the config available to both the mutator and transpiler.</li><li><strong>Mutator</strong>: A plugin that can mutate TypeScript code. See <a href="https://github.com/stryker-mutator/stryker-js/tree/master/packages/stryker-typescript/test/unit/mutator">our unit tests</a> to know what mutations are support.</li><li><strong>Transpiler</strong>: A plugin that can transpile (mutated) TypeScript code. It uses your tsconfig settings, so the output will be exactly as you&#x27;d expect.</li></ol><p>To configure the plugins you need to add this to your stryker.conf.js file:</p><pre><code class="language-javascript">module.exports = function (config) {
  config.set({
    // ...
    mutator: &#x27;typescript&#x27;,
    transpilers: [&#x27;typescript&#x27;],
    tsconfigFile: &#x27;tsconfig.json&#x27;,
    // ...
  });
};
</code></pre><h3>Great! But what about performance?</h3><p>You might be thinking all this has a negative impact on performance.
After all, we have to transpile the TypeScript code for each mutant we want to test.
When running Stryker on itself we notice that it takes less time than before when we were mutating JavaScript.
This is because transpiling each mutant ensures that no false positives are tested. Results for your project may differ.</p><p>Take the <a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-typescript/src/mutator/BinaryExpressionMutator.ts">BinaryExpressionMutator</a>
for example. It might mutate:</p><pre><code class="language-typescript">&#x27;foo&#x27; + &#x27;bar&#x27;;
</code></pre><p>into:</p><pre><code class="language-typescript">&#x27;foo&#x27; - &#x27;bar&#x27;;
</code></pre><p>Although this would be valid in JavaScript, it is <em>invalid</em> in TypeScript.
This means that the mutant will result in a <code>TranspileError</code>. It is <em>not</em> tested and <em>not</em> calculated into your mutation score.
Less work means it can be faster.</p><h2>What&#x27;s next?</h2><p>Next, we want to further improve upon our TypeScript support. For example we want to add support
for <a href="https://github.com/stryker-mutator/stryker-js/tree/master/packages/stryker#type-of-coverage-analysis">coverage analysis</a>
when using a transpiler. We&#x27;re also thinking about an es6 mutator using Babel under the hood.</p><p>Please let us know what you think.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stryker 0.8 release]]></title>
        <id>stryker-0-8-0</id>
        <link href="https://stryker-mutator.io/blog/stryker-0-8-0"/>
        <updated>2017-08-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Stryker 0.8 just released with better CI integration and configurable thresholds.]]></summary>
        <content type="html"><![CDATA[<p>Stryker 0.8 just released with better CI integration and configurable thresholds.</p><p>For the entire changelog per package:</p><ul><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker/CHANGELOG.md">stryker changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-api/CHANGELOG.md">stryker-api changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-html-reporter/CHANGELOG.md">stryker-html-reporter changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-mocha-runner/CHANGELOG.md">stryker-mocha-runner changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-mocha-framework/CHANGELOG.md">stryker-mocha-framework changelog</a></li></ul><h2>Better CI integration</h2><p><a href="https://github.com/stryker-mutator/stryker-js/pull/355">Original PR</a></p><p>It&#x27;s now possible to let your build fail based on your mutation score.
The way to do this is to make sure stryker runs inside your (nightly) build and configure the <code>threshold.break</code> value:</p><pre><code class="language-javascript">// stryker.conf.js
// ...
thresholds: {
    break: 70, // Fail if mutation score &lt; 70
    // ..
}
// ...
</code></pre><p>This will break the build if your mutation score falls below 70%.</p><pre><code class="language-bash">[2017-08-11 13:46:10.190] [ERROR] ScoreResultCalculator - Final mutation score 66.97 under breaking threshold 70, setting exit code to 1 (failure).
npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! stryker@0.8.0 stryker: `node bin/stryker run`
</code></pre><p>Want to know what a &#x27;mutation score&#x27; is? See <a href="../docs/General/faq">our faq</a>.</p><h2>Configurable color thresholds</h2><p><a href="https://github.com/stryker-mutator/stryker-js/pull/355">Original PR</a></p><p>The clear-text and html reporters now honor configured high and low thresholds.
You once again configure it using the <code>thresholds</code> config option:</p><pre><code class="language-javascript">// stryker.conf.js
// ...
thresholds: {
    high: 80,
    low: 60,
    // ...
}
// ...
</code></pre><p>Configuring these values will color mutation scores above 80% <span class="text-success">green</span>, between 80 and 60% <span class="text-warning">yellow</span> and anything below 60% <span class="text-danger">red</span>.
You can see an example of an html report based on stryker itself <a href="https://stryker-mutator.github.io/stryker-html-reporter">here</a>.</p><h2>Bugfixes</h2><p>Bugfixes this release:</p><ul><li><a href="https://github.com/stryker-mutator/stryker-js/issues/335">Incorrect relative path for html reporter #355</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/issues/350">Mutation testing in node based environments can generate false warnings #350</a></li></ul><h2>Enjoy!</h2><p>Enjoy this new release! We&#x27;re always happy with feedback, negative or positive.</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Road to Stryker 1.0]]></title>
        <id>road-to-stryker-1-0</id>
        <link href="https://stryker-mutator.io/blog/road-to-stryker-1-0"/>
        <updated>2017-07-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Stryker is about two years old. During this time we achieved a lot. But it's far from finished. So, what's next? Let's take a glimpse in the future.]]></summary>
        <content type="html"><![CDATA[<p>Stryker is about two years old. During this time we achieved a lot. But it&#x27;s far from finished. So, what&#x27;s next? Let&#x27;s take a glimpse in the future.</p><p>Some of Strykers achievements are:</p><ul><li>Stryker is the first functional mutation testing framework for JavaScript.</li><li>Stryker is test framework and test runner agnostic.</li><li>Stryker boosts performance by running tests in parallel.</li><li>Stryker uses advance coverage analysis to do less work.</li></ul><p>The way Stryker achieves all this, is using a plugin model. Want to use a different test runner?
Create a class that implements the <a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-api/src/test_runner/TestRunner.ts">TestRunner interface</a> and you&#x27;re done.
However, Stryker does one assumption: your source code can be directly executed in your environment.</p><h2>Road to v1</h2><p>We&#x27;re very happy with the results so far, but we&#x27;re far from done. The JavaScript world is constantly evolving.
A couple of examples of modern use cases are:</p><ul><li>A web project written in JSX / <a href="https://facebook.github.io/react/">React</a></li><li>A node project written in <a href="https://www.typescriptlang.org/">TypesScript</a> and executed using <a href="https://www.npmjs.com/package/ts-node">ts-node</a></li><li>An Angular project generated with the <a href="https://www.npmjs.com/package/@angular/cli">angular cli</a> using <a href="https://webpack.js.org/">webpack</a> and <a href="https://www.typescriptlang.org/">TypeScript</a></li><li>A web project using <a href="https://vuejs.org/">VueJS</a></li><li>A web component written in HTML5 using <a href="https://www.polymer-project.org">Polymer</a> and <a href="https://webpack.js.org/">webpack</a></li></ul><p>In order to stay relevant, these use cases need to be supported in a user friendly way.
Only then are we comfortable with tagging Stryker with a version <em>1</em> tag.</p><h2>False assumption</h2><p>If you look at the modern use cases, they have something in common:
your code cannot be directly executed in your JavaScript environment. It&#x27;s not even JavaScript in some cases.
It first needs to be compiled, transpiled and/or bundled, before it can be executed.
For the sake of this article, let&#x27;s call this step <a href="https://en.wikipedia.org/wiki/Source-to-source_compiler">transpiling</a>.
This makes the assumption that Stryker does a false one: <strong>it should not assume the code you write is the code that gets executed</strong>.</p><h2>First attempt</h2><p>We&#x27;ve had a lot of discussion within the Stryker team on how to support these use cases.
One possibility is to first transpile your code before we run the normal Stryker process on it.</p><p>In the end we decided against this approach, because it comes with a big downside: it will cause a lot of false positives.</p><p>Let&#x27;s take this piece of TypeScript code as an example:</p><pre><code class="language-typescript">const b = 42;
const a = `the answer is ${b}`;
</code></pre><p>This might transpile to:</p><pre><code class="language-javascript">var b = 42;
var a = &#x27;the answer is &#x27; + b;
</code></pre><p>When Stryker comes along: it changes <code>&#x27;the answer is &#x27; + b</code> to <code>&#x27;the answer is &#x27; - b</code>.
This is a valid mutation for JavaScript (if you&#x27;re curious: the answer is <code>NaN</code>).
However, <code>&#x27;the answer is &#x27; - b</code> is <em>not a valid TypeScript expression</em>. It results in the following compile error:</p><pre><code class="language-bash">The left-hand side of an arithmetic operation must be of type &#x27;any&#x27;, &#x27;number&#x27; or an enum type.
</code></pre><p>This is why we refer to it as a false positive. This mutation shouldn&#x27;t be tested, because it&#x27;s a waste of resources and it impacts the mutation score. This is why we shouldn&#x27;t blindly mutate transpiled code.</p><h2>Open heart surgery</h2><p>The only solution for supporting these use cases is to transpile the code after it has been mutated. This way, we can make sure only valid mutations are done to your code because
we <em>teach</em> Stryker which mutations are valid and which are invalid and we won&#x27;t have to worry about code that gets generated during the transpilation.</p><p>However, we don&#x27;t want to just hard code it all in Stryker, because that would force a dependency on TypeScript, Babel, Webpack, etc.
Instead the transpiling and mutating of the code will be the responsibility of a new plugin type.
Let&#x27;s call this the <code>transpiler</code> plugin. Examples of these plugins may be (in the future): <code>stryker-typescript-transpiler</code>, <code>stryker-javascript-transpiler</code>, <code>stryker-babel-transpiler</code>, <code>stryker-webpack-transpiler</code></p><p>We&#x27;ve sketched the new workflow for the TypeScript use case on a whiteboard:</p><p><img src="/images/blogs/transpiler-plugin.jpg" alt="transpiler-plugin"/></p><p>Let&#x27;s explain what happens in 2 steps:</p><ol><li>Initial test run</li><li>Mutation testing</li></ol><h3>Step 1: Initial test run</h3><p>Starting from the top left: Stryker starts by reading your Stryker configuration file.
After that, we read in the source files into memory. As you might have noticed, these will be the <em>typescript files</em>.
Next up: it&#x27;s the new <code>stryker-typescript-transpiler</code> plugin&#x27;s time to shine. It will transpile the <em>.ts files into </em>.js files
and it will use your &quot;tsconfig.json&quot; configuration for this. The JavaScript output of this process will
be written to disk by Stryker in something that we call a <em>Sandbox</em>. In this Sandbox, Stryker can
start the initial test run as usual.</p><p>Why this complicated setup? After all, if we want to do an initial test run, we might as well just let your build process transpile the code
and run the tests using your test runner. The answer is that we need a baseline of your tests ran by Stryker.
In the next step, Stryker will write mutations to different Sandboxes and run your tests.
We need a control step to make sure your tests pass under normal circumstances. Also: this is where
we measure your code coverage results for every test (if your test framework and test runner support it), which
are used to speed up mutation testing.</p><h3>Step 2: Mutation testing</h3><p>After the initial test run completed successfully, we proceed with the actual mutation testing. The first step here
is about figuring out how we can mutate your source code. This is again done by the <code>stryker-typescript-transpiler</code> plugin.
It will mutate the TypeScript specific <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a>, but <em>only
in valid ways</em>. For example: it won&#x27;t mutate <code>&#x27;the answer is &#x27; + 42</code> into <code>&#x27;the answer is &#x27; - 42</code>, but it might
mutate it into <code>&#x27;Stryker was here&#x27; + 42</code>. The output of this process is a list of (in-memory) mutants.</p><p>A mutant will have 2 parts: a TypeScript part and a JavaScript part. Stryker itself only cares about the
JavaScript part, because that is the recipe to mutate the JavaScript code in the sandboxes.
This will allow Stryker to do mutation testing without needing to compile the code for each mutant, which would be disastrous for performance.
The TypeScript part of a mutant can be used to report the mutated code to the end user. So the mutants that will be reported
in the exact code and language that the end user uses.</p><h2>Plain JavaScript projects</h2><p>Back to plain JavaScript projects. What will change for them? The answer is: not much.
We&#x27;ll basically move the current logic for mutating code to a new <code>stryker-javascript-transpiler</code> plugin.
It will be a pass-through transpiler, meaning that the code you write will be used directly.
Mutating of JavaScript code will move to this plugin as well.</p><h2>Want to help?</h2><p>Want to help? Great! We&#x27;re really looking for people interested in helping us reach our goal of supporting all JavaScript based projects!</p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stryker 0.6.4 released]]></title>
        <id>stryker-0-6-4</id>
        <link href="https://stryker-mutator.io/blog/stryker-0-6-4"/>
        <updated>2017-06-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[This release of Stryker brings a number of new features and improvements. Including a new quickstart and a number of reporter improvements.]]></summary>
        <content type="html"><![CDATA[<p>This release of Stryker brings a number of new features and improvements. Including a new quickstart and a number of reporter improvements.</p><p>For the entire changelog per package:</p><ul><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker/CHANGELOG.md">stryker changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-api/CHANGELOG.md">stryker-api changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-mocha-runner/CHANGELOG.md">stryker-mocha-runner changelog</a></li><li><a href="https://github.com/stryker-mutator/stryker-js/blob/master/packages/stryker-mocha-framework/CHANGELOG.md">stryker-mocha-framework changelog</a></li></ul><h2>New quickstart</h2><p>A new version of Stryker has been released that comes with a new way to initialize your project: an interactive questionnaire.</p><p>Previously, when you wanted to start using Stryker in your project, you probably used the quickstart on the website.
Instead of evolving the quickstart on the website, we&#x27;ve chosen to build it right into Stryker. Try it out: <code>stryker init</code>.</p><p><img src="/images/blogs/stryker-init.gif"/>
<strong>Note:</strong> This is using the new <a href="https://www.npmjs.com/package/stryker-cli">stryker-cli</a>. More on that in a separate blog article.</p><p>This new &#x27;init&#x27; command has some advantages:</p><ul><li>The test runners, test frameworks and reporters are <strong>dynamically queried</strong> on npm.</li><li>You can only select <strong>test frameworks</strong> that are actually <strong>supported by your test runner</strong>.</li><li>The required plugins are <strong>automatically installed</strong>.</li><li>Your Stryker configuration gets <strong>automatically generated</strong>.</li></ul><p><strong>A note for plugin creators</strong>: <code>stryker init</code> will automatically find your plugin as long as you add the correct keywords to your <code>package.json</code> file.
More on that in a separate article or take a look at the PR.</p><p>Please take a look at <a href="https://github.com/stryker-mutator/stryker-js/pull/269">PR #269 for more details</a></p><h2>New clear-text reporter summary</h2><p>The summary at the end of the clear-text reporter got a new look:</p><pre><code class="language-js">-----------|---------|----------|-----------|------------|----------|---------|
File       | % score | # killed | # timeout | # survived | # no cov | # error |
-----------|---------|----------|-----------|------------|----------|---------|
All files  |   69.57 |       16 |         0 |          3 |        4 |       0 |
Add.js     |   82.35 |       14 |         0 |          1 |        2 |       0 |
Circle.js  |   33.33 |        2 |         0 |          2 |        2 |       0 |
-----------|---------|----------|-----------|------------|----------|---------|
</code></pre><p>This works with a new reporter callback: <code>onScoreCalculated</code>, which provides a tree
of score results per directory/file. This should be used as a single source of truth for all reporters.
We&#x27;re planning to migrate the stryker-html-reporter to this new way of working.</p><p>Please take a look at <a href="https://github.com/stryker-mutator/stryker-js/pull/309">PR #309 for more details</a></p><h2>Stryker mocha framework</h2><p>Previously, the stryker-mocha-framework was included in the stryker-mocha-runner package. We&#x27;ve noticed that this was quite confusing.
That&#x27;s why it&#x27;s now migrated in it&#x27;s own package.</p><p><strong>BREAKING CHANGE:</strong> If you are using <code>testRunner: &#x27;mocha&#x27;, testFramework: &#x27;mocha&#x27;</code> right now,
please also install stryker-mocha-framework when upgrading from <a href="mailto:stryker-mocha-runner@0.3.x">stryker-mocha-runner@0.3.x</a> to <a href="mailto:stryker-mocha-runner@0.4.0">stryker-mocha-runner@0.4.0</a>.</p><p>The stryker-mocha-framework currently only supports test runner &#x27;mocha&#x27;. You&#x27;ll get a warning when you configure an other runner.
As configuring a test framework is always optional, you&#x27;ll still be able to run your mocha tests in karma.</p><p>Please take a look at <a href="https://github.com/stryker-mutator/stryker-js/pull/308">PR #308 for more details</a></p><h2>New mutator</h2><p>Please welcome our latest mutator: <strong>boolean substitution</strong>. It mutates your code in 3 ways:</p><pre><code class="language-js">true -&gt; false
false -&gt; true
!a -&gt; a
</code></pre><p>Please take a look at <a href="https://github.com/stryker-mutator/stryker-js/pull/294">PR #294 for more details</a></p>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stryker weekend]]></title>
        <id>stryker-weekend</id>
        <link href="https://stryker-mutator.io/blog/stryker-weekend"/>
        <updated>2017-02-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[During the last weekend of January we spent a weekend with ten students from the HAN University and University of Twente developing valuable features for Stryker!]]></summary>
        <content type="html"><![CDATA[<p>During the last weekend of January we spent a weekend with ten students from the HAN University and University of Twente developing valuable features for Stryker!</p><p>The group was divided into four teams, each with their own goal. Nico Jansen provided a short TypeScript course to get everyone up to speed on developing using TypeScript and after that everyone started working hard on improving Stryker.</p><p><img src="/images/blogs/stryker-weekend-team-photo.jpg"/></p><p><a href="https://github.com/Archcry">Sander</a> and <a href="https://github.com/wesselhendriks">Wessel</a> decided to dive deep into the Stryker codebase to introduce <code>async</code>-<code>await</code> in as much of the Stryker repository as possible. They learned that it was not possible to use it everywhere, but nevertheless it cleaned up the codebase nicely!</p><p><a href="https://github.com/Floormidabel">Florian</a> and <a href="https://github.com/stienis96">Stijn</a> decided to introduce another new TypeScript feature. They added the <code>strictNullChecks</code> feature to the Stryker codebase. By adding the feature, they force us to write cleaner code. However, before they could compile the codebase with the feature turned on they had to fix two full pages filled with errors, but that didn&#x27;t stop Olaf and Stijn!</p><p>Not everyone decided to try out new TypeScript features, some also decided to improve the core functionality of Stryker: mutating code. <a href="https://github.com/JellePetersHAN">Jelle</a>, <a href="https://github.com/MarktHart">Mark</a> and <a href="https://github.com/Wouter1810">Wouter</a> added two new mutators and added tests for one of the existing mutators. Their <code>ArrayDeclarationMutator</code> is capable of creating an empty array whenever you initialize an array with values. For example, the code <code>[1, 2, &#x27;Hello&#x27;]</code> could be mutated to: <code>[]</code>. They also added the <code>ConstantNumberMutator</code> which will change the declaration of a <code>const</code> to <code>0</code>.</p><p>Last but not least, <a href="https://github.com/korthout">Nico</a>, <a href="https://github.com/OlafHaalstra">Olaf</a>, <a href="https://github.com/DiedB">Diederik</a> and <a href="https://github.com/avassem85">Alex</a> worked on improving the onboarding of new projects by creating the stryker-cli. This tool is capable of integrating Stryker into your project in an interactive way. It&#x27;s even capable of installing the required packages so you can start using Stryker with minimal effort!</p><p>In the end, the weekend was a success. We all had a blast and we managed to develop more features than we had expected. The students exceeded our expectations with their skill and enthusiasm. This is something we definitely want to do more often!</p><p><img src="/images/blogs/stryker-ascii.jpg"/></p>]]></content>
        <author>
            <name>Simon de Lang</name>
            <uri>https://github.com/simondel</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Introduction to mutation testing]]></title>
        <id>introduction-to-mutation-testing</id>
        <link href="https://stryker-mutator.io/blog/introduction-to-mutation-testing"/>
        <updated>2017-01-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Writing unit tests can be hard. Even for an easy example such as a calculator app.]]></summary>
        <content type="html"><![CDATA[<p>Writing unit tests can be hard. Even for an easy example such as a calculator app.
There are unlimited combinations of inputs for a calculator and you&#x27;re not going to test every single one. So when are you done testing?</p><p>Say you&#x27;re building an online casino, users can only enter the casino when they&#x27;re over 18. So you write the following piece of code to check if someone is allowed to use the website:</p><pre><code class="language-javascript">function isUserOldEnough(user) {
  return user.age &gt;= 18;
}
</code></pre><p>Easy right? So what inputs do you use to test? Perhaps you would pick your own age (25 for example) if you&#x27;re over 18 and pick something below 18 (16 or so) to check the other outcome.
You run your code coverage tool on the code and it turns out your code is 100% covered. Great, we&#x27;re done testing!</p><h2>The code coverage problem</h2><p>I used to think that code coverage tells you which code is tested. But I realized I was wrong. Code coverage doesn‚Äôt tell you which code is tested, it only tells you which code is being executed during testing. There is an important difference here. You could write one test which hits 100 lines of code, but that doesn‚Äôt mean that all 100 lines of code work as you would expect. If you would write 10 tests for that piece of code, you may still have the same code coverage. You could even write tests without assertions to boost your code coverage.</p><p>And how do you know that enough is enough? Some teams even have code coverage goals that they have to hit (100% anyone?). As if that would make you write better tests. Sure, it forces you to write tests, but it doesn‚Äôt promise that they‚Äôre good tests. It even encourages bad behavior for some people. During one of my projects as a student, our school decided a little competition would be fun. The team with the highest code coverage at the end of the project would win a small prize. It didn‚Äôt take long to find out that tests could be written without assertions to easily boost their code coverage (of course, I would never do that ;)).</p><p>The only way to know that a test actually <em>works</em> is when it fails when you make a code change.</p><h2>Mutation testing</h2><p>You could go through your code base and make changes to see if certain tests fail. However, this process is time consuming. You&#x27;re much better off using a mutation testing framework. A mutation testing framework will look through your code to see where it can introduce bugs, which we will call <em>mutants</em> from now on.</p><p>Say you have the following code:</p><pre><code class="language-javascript">function isUserOldEnough(user) {
  return user.age &gt;= 18;
}
</code></pre><p>A mutation testing framework will find the return statement and decide to change it in a number of ways:</p><pre><code class="language-javascript">/* 1 */ return user.age &gt; 18;
/* 2 */ return user.age &lt; 18;
/* 3 */ return false;
/* 4 */ return true;
</code></pre><p>Each one of those mutants should make a test fail. After the mutants have been found, they are applied one by one and your tests will be executed. If at least one of your tests fail, we say the mutant is <em>killed</em>. If no tests fail, it <em>survived</em>. The better your tests, the less mutants survive. The first mutant would have survived if we had a test with a user aged 16 and 25, since we didn&#x27;t test the boundary.</p><p>With mutation testing you‚Äôre testing your tests.</p><h2>Getting started</h2><p>The best thing to do if you‚Äôre not already using mutation testing is to just try it once. Most languages have a mutation testing framework.
Just take a look on GitHub and you will probably find one for the language you use.</p><p>If you‚Äôre using JavaScript, I would suggest looking at Stryker. It has a great <a href="http://stryker-mutator.github.io/quickstart.html">quickstart page</a> to get you up and running.</p><p>If you&#x27;ve first used a mutation testing framework, you may find that there are a lot of mutations that survive, but that‚Äôs ok!</p><h2>Setting goals</h2><p>After you‚Äôve used a mutation framework a couple of times, you may think about setting a mutation testing goal,
just like with your code coverage goal. I sometimes get asked what a good goal is for mutation testing.
It can be a difficult question to answer and I honestly don‚Äôt know what a good goal is for your application.</p><p>Mutation testing frameworks make very different changes depending on the language or even framework you‚Äôre using.
Stryker could assign any value to any variable since it tests JavaScript. That doesn‚Äôt work for a framework like <a href="http://pitest.org/">PIT</a>,
which can be used to mutation test Java code. This means that your score could differ a lot depending on the language and framework you use.
The goal you want to set may also differ depending on the type of application that you&#x27;re writing. A banking application may require a higher mutation score than some side project.</p><p>I would suggest running a mutation testing framework and set a higher goal than your current score.
I would not advise to make 100% mutation coverage your goal though. The most important thing is that you write good tests and mutation testing can help you achieve that.
So if you‚Äôre going to set any goal, make writing good tests your goal.</p>]]></content>
        <author>
            <name>Simon de Lang</name>
            <uri>https://github.com/simondel</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Happy new Stryker!]]></title>
        <id>happy-new-stryker</id>
        <link href="https://stryker-mutator.io/blog/happy-new-stryker"/>
        <updated>2017-01-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[2017 - The year to invest into test quality]]></summary>
        <content type="html"><![CDATA[<h2>2017 - The year to invest into test quality</h2><p>Up until now, when you were writing unit tests, you were actually investing in <em>code quality</em>. Catching bugs early by continuously
exercising your code with unit tests and keeping your stakeholders happy by presenting them with a code coverage number of 85% or higher.
But does code coverage tell the entire story? Are your tests actually able to detect bugs? How do you test <em>your tests</em>?
That&#x27;s the problem <a href="https://en.wikipedia.org/wiki/Mutation_testing">mutation testing</a> sets out to solve.</p><h3>Mutation testing in JavaScript</h3><p>Due to JavaScript&#x27;s dynamic nature, unit testing has become a fundamental tool to bring a higher level of robustness to JavaScript projects.
Your average JavaScript app can easily have around 1,000 unit tests. Ensuring that these are actually <em>effective</em> can be a full-time job. This is where Stryker comes in.
<a href="http://stryker-mutator.github.io/">Stryker Mutator</a> is our approach to providing a comprehensive mutation testing tool for the JavaScript environment.</p><p>We start out by altering your source code ever so slightly (e.g. turning a <code>+</code> into <code>-</code>) and then running your tests to see if they are
resilient to this <em>&quot;mutant&quot;</em>. If they are (and they fail), all is fine - the <em>mutant is dead</em>. If they don&#x27;t, the <em>mutant</em> survived and you have to fix your test.</p><h2>Stryker Hackweek 2016</h2><p>Stryker began its life as the thesis project of Simon de Lang. After graduating, his thesis tutor Nico Jansen joined him and continued development in the open on <a href="https://github.com/stryker-mutator/">GitHub</a>.
Since then they had five major releases, improving performance, adding support for the <a href="http://karma-runner.github.io/1.0/index.html">Karma</a> and <a href="http://mochajs.org/">Mocha</a> test runners,
as well as creating a fancy <a href="https://github.com/stryker-mutator/mutation-testing-elements/tree/master/packages/mutation-testing-elements">HTML reporter</a>.</p><p>Up until now, the two of them did all of this in their own time, next to their daytime jobs as software engineers.</p><p>Around came the traditionally slow Christmas time period, allowing a select few of their colleagues at <a href="https://www.infosupport.com/">Info Support</a> to join them for 4 days for the <strong><em>Stryker Hackweek 2016</em></strong>.</p><h3>Achieved goals</h3><p>The whole team enjoyed the experience a lot and had good fun extending Stryker and fixing issues.
We mostly concentrated on integrating Stryker with SonarQube, as well as improving the first time usage experience.</p><p>All in all we made <strong>47 commits</strong>, closed <strong>18 issues</strong>, eat <strong>6 kebabs</strong> and <strong>4 subway sandwiches</strong>!
Here&#x27;s a quick overview of what we did:</p><ul><li>Created a <a href="https://github.com/stryker-mutator/sonar-stryker-plugin">Stryker SonarQube plugin</a>, that turns survived mutants into neat SonarQube issues</li><li>Added <a href="http://stryker-mutator.github.io/blog.html">a blog</a> to the Stryker homepage</li><li>Upgraded the TypeScript compiler in all projects to 2.1</li><li>Released <a href="http://stryker-mutator.github.io/blog/2016-12-30/stryker-0-5-5.html">version 0.5.5 of Stryker</a>, including:<ul><li>A new progress reporter</li><li>Limit the number of test-names to log in the clear text reporter</li><li>Support to <a href="https://github.com/stryker-mutator/stryker-js/issues/90">exclude online files from globbing</a></li></ul></li><li>Support for <a href="https://github.com/stryker-mutator/stryker-js/tree/master/packages/stryker-karma-runner/issues/7">karma config parsing in the stryker-karma-runner</a></li><li>Improved documentation for first time-users</li><li>A plan for a series of blog articles</li></ul><h3>The Hackweek Team</h3><p><img src="/images/blogs/stryker-team-photo.jpg" alt="The Hackweek Team (f.l.t.r.): Alex van Assem, Nico Jansen, Simon de Lang, Philipp Weissenbacher, Jasper Catthoor, Wannes Van Regenmortel"/></p><p>The Stryker Hackweek team consisted of (from left to right):</p><ul><li>Alex van Assem: Agile coach and TypeScript hacker</li><li>Nico Jansen: T-shaped software engineer</li><li>Simon de Lang: Software engineer and TypeScript aficionado</li><li>Philipp Weissenbacher: Software/BI engineer</li><li>Jasper Catthoor: Software engineer (via Info Support Belgium)</li><li>Wannes Van Regenmortel: Software engineer (via Info Support Belgium)</li></ul><h4>Want to try out Stryker? Begin with the handy <a href="http://stryker-mutator.github.io/quickstart.html">quick start guide</a>.</h4>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Stryker 0.5.5 released!]]></title>
        <id>stryker-0-5-5</id>
        <link href="https://stryker-mutator.io/blog/stryker-0-5-5"/>
        <updated>2016-12-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[The full changelog can be found on GitHub. In this post we'll dive into a couple of new features.]]></summary>
        <content type="html"><![CDATA[<p>The full changelog can be found on <a href="https://github.com/stryker-mutator/stryker-js/blob/master/CHANGELOG.md">GitHub</a>. In this post we&#x27;ll dive into a couple of new features.</p><p>To upgrade to Stryker 0.5.5, simply run: <code>npm i --save-dev stryker-api@0.4.2 stryker@0.5.5</code></p><h3>New progress reporter</h3><p>The <code>progress</code> reporter got a fresh new look! It will now display a progress bar, the percentage of doneness and an ETC (Estimated Time of Completion).
Gone are the days of guessing how far Stryker has come and how long it&#x27;ll need!
You can use it by setting reporter to <code>&#x27;progress&#x27;</code> in your <code>stryker.conf.js</code>.</p><p><strong>The new progress reporter looks like this:</strong>
<img src="/images/blogs/progress-reporter.png" alt="new progress reporter image"/></p><p>Do you still want to use the <strong>old</strong> reporter? It&#x27;s still there! Just use the repoter <code>&#x27;dots&#x27;</code> in your configuration.</p><h3>Clear text reporter updated</h3><p>The clear text reporter no longer prints every single test that was executed for a mutant. It now only prints the first three tests and mentions how many more tests were executed.
If desired, you can overwrite this behavior by adding the following piece of config to your <code>stryker.conf.js</code>:</p><pre><code class="language-js">clearTextReporter: {
    maxTestsToLog: 25
},
</code></pre><p>Don&#x27;t want to know which tests were executed? Feel free to set the <code>maxTestsToLog</code> property to 0.</p><h3>Karma config parsing</h3><p>In addition to this release of Stryker, we&#x27;ve also added support for an often requested feature: reading your existing <code>karma.conf.js</code> in the <a href="https://github.com/stryker-mutator/stryker-js/tree/master/packages/stryker-karma-runner">stryker-karma-runner</a>!
Starting with version 0.3.3, you can add the location of your karma config file to <code>Stryker.conf.js</code> and have it automatically be picked up by the plugin. This reduces code duplication between these two files.</p><p>This is what your new <code>stryker.conf.js</code> might look like:</p><pre><code class="language-js">// Stryker.conf.js
module.exports = function (config) {
    config.set({
        testRunner: &#x27;karma&#x27;,
        testFramework: &#x27;jasmine&#x27;, // &lt;-- add your testFramework here
        karmaConfigFile: &#x27;karma.conf.js&#x27; // &lt;-- add your karma.conf.js file here
        mutate: [
            &#x27;src/**/*.js&#x27; // &lt;-- mark files for mutation here
        ]
    });
}
</code></pre><p>As you can see, there is no need to specify which files Stryker should use! You only have to specify which files you want to mutate.
A more detailed explanation of this feature can be found in the <a href="https://github.com/stryker-mutator/stryker-js/tree/master/packages/stryker-karma-runner/blob/master/README.md#configuring">stryker-karma-runner README.md</a>.</p><h4>We hope you enjoy this new version of Stryker! We&#x27;d love to hear your feedback on <a href="https://join.slack.com/t/stryker-mutator/shared_invite/enQtOTUyMTYyNTg1NDQ0LTU4ODNmZDlmN2I3MmEyMTVhYjZlYmJkOThlNTY3NTM1M2QxYmM5YTM3ODQxYmJjY2YyYzllM2RkMmM1NjNjZjM">Slack</a> and/or Twitter (with hashtag #strykermutator)!</h4>]]></content>
        <author>
            <name>Nico Jansen</name>
            <uri>https://github.com/nicojs</uri>
        </author>
    </entry>
</feed>